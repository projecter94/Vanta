const { Client, GatewayIntentBits } = require('discord.js');
const fetch = require('node-fetch');

const API_URL = "https://xed.onrender.com/";
const ADMIN_SECRET = "vanta_supersecretkey_2025_ABC123";

const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent] });


client.on('messageCreate', async message => {
    if (!message.content.startsWith("!")) return;

    const args = message.content.split(" ");
    const command = args[0];

    async function callAdmin(endpoint, body) {
        const res = await fetch(`${API_URL}/admin/${endpoint}`, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${ADMIN_SECRET}`
            },
            body: JSON.stringify(body)
        });
        return await res.json();
    }

    if (command === "!addkey") {
        const key = args[1];
        const resp = await callAdmin("addkey", { key });
        message.reply(JSON.stringify(resp));
    }

    if (command === "!deletekey") {
        const key = args[1];
        const resp = await callAdmin("deletekey", { key });
        message.reply(JSON.stringify(resp));
    }

    if (command === "!resethwid") {
        const key = args[1];
        const resp = await callAdmin("resethwid", { key });
        message.reply(JSON.stringify(resp));
    }

    if (command === "!whitelist") {
        const key = args[1];
        const userId = args[2];
        const resp = await callAdmin("whitelist", { key, userId });
        message.reply(JSON.stringify(resp));
    }

    if (command === "!unwhitelist") {
        const key = args[1];
        const resp = await callAdmin("unwhitelist", { key });
        message.reply(JSON.stringify(resp));
    }
});

client.login(BOT_TOKEN);























getgenv().BaitConfig = {
    Enabled = getgenv().Bait or false,   -- Controlled by bait! on/off
    Interval = 1.4,                      -- Time between bait pulses
    UpDistance = 1000,                   -- How high to teleport
    HoldTime = 0.175,                     -- How long to stay in void/air
    LastBait = 0                         -- Internal timer
}

-- // ==================== NEW ADVANCED COMBAT CONFIG (AUTOMATIC ON K!/S!/L!) ==================== //
getgenv().CombatSettings = {
    Prediction = {
        Multiplier = 1.8,
        Base = 0.02
    },
    Offsets = {
        Random = 25, -- 25s
        StompHeight = 3, 
        StompRandom = 0, -- 0s
        StrafeRandom = 2, -- 02 (2 studs)
        Detailed = {
            AntiClip = true,
            X_Min = 64,
            X_Max = -67,
            Y_Min = 59,
            Y_Max = -60,
            Z_Min = 34,
            Z_Max = -32,
            Rotation = 360 -- 360 degrees for Pitch/Yaw/Roll
        }
    },
    Resolver = {
        RefreshTime = 1.5,
        Forgiveness = 7.9,
        Bonus = 5.1,
        DistancePenalty = 0.6,
        DisableOutOfVoid = true
    },
    Spiral = {
        Distance = 89,
        Speed = 6.71
    },
    VoidSpam = {
        InVoid = 0.42,
        OutVoid = 0.11
    }
}

getgenv().VelocityBreaker = false
getgenv().VelocityBreakerConfig = {
    Type = "Reverse",
    Multiplier = 100
}

local AdvMessages = {
    "Join Vanta if you want to be goated in every server G G/nwjVsDBeyn",
    "The script is clean, smooth, and actually works without lag JHHGneSJ9g",
    "Stop getting wiped by exps and start owning every fight G G/njnhehTPDA",
    "Features that make you unstoppable in any game JHHGneSJ9g",
    "Vanta is for anyone who wants top-tier scripts and zero frustration G G/nwjVsDBeyn",
    "Tired of mid gameplay? Join and instantly get better G G/njnhehTPDA",
    "Exps won’t touch you while you flex with Vanta’s features JHHGneSJ9g",
    "Smooth UI, reliable tools, and full control every server G G/nwjVsDBeyn",
    "Be the player everyone fears and respects G G/njnhehTPDA",
    "Wanna dominate servers and flex on everyone Join Vanta JHHGneSJ9g",
    "Stop dying to exploiters and start winning every fight G G/nwjVsDBeyn",
    "Be the player that sets the meta instead of following it G G/njnhehTPDA",
    "The script is loaded with clean features that make you goated JHHGneSJ9g",
    "Join now and be the legend that everyone talks about G G/nwjVsDBeyn",
    "Join now and see why Vanta players are unstoppable G G/nwjVsDBeyn"
}

-- // ==================== FIXES & NEW CONFIGS ==================== //

-- [1] Toggle for Advanced/Desync Mode (Default: true)
getgenv().UseAdvancedCombat = true 

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Forward Declarations (CRITICAL FIX)
local ScriptRunning = true
local ActivateStompMode = nil
local ActivateUndergroundAttack = nil

-- [2] Helper function for Chat (Fixes inv! and advtext!)
local function SendChatMessage(text)
    pcall(function()
        if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then
            local channel = game:GetService("TextChatService").TextChannels.RBXGeneral
            if channel then channel:SendAsync(text) end
        else
            game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(text, "All")
        end
    end)
end

local OWNER_NAME = getgenv().VantaOwner
local ORIGINAL_OWNER_NAME = OWNER_NAME -- Backup for r! command assurance

if not getgenv().BaitConfig then
    getgenv().BaitConfig = {
        Enabled = getgenv().Bait or false,   -- Controlled by bait! on/off
        Interval = 0.7,                      -- Time between bait pulses
        UpDistance = 1000,                   -- How high to teleport
        HoldTime = 0.175,                     -- How long to stay in void/air
        LastBait = 0                         -- Internal timer
    }
end

------------------------------------------------
local BaitConfig = getgenv().BaitConfig

-- MULTISTAND CONFIG
local Multistand = getgenv().MultiStand or false

-- MULTI-TARGET QUEUE
local MultiTargetQueue = {}

-- PROTECTION LIST
getgenv().sentryprotected = getgenv().sentryprotected or {}
getgenv().whitelisted = getgenv().whitelisted or {} -- NEW: Whitelist table
getgenv().lastHealths = getgenv().lastHealths or {}
------------------------------------------------

-- Player References
local LocalPlayer = Players.LocalPlayer
local OwnerUsername = OWNER_NAME
local OwnerChatConnections = {}

-- PREDICTION CONFIG
local PREDICTION_TIME = getgenv().Prediction or 0.15

-- // ==================== ANIMATIONS REMOVED ==================== //
-- Custom animations have been completely stripped per request.
-- // ============================================================ //

-- Forward declaration of modes to check status
local isKnockMode = false
local isStompMode = false
local isLoopMode = false
local isGrabMode = false
local isSyncStomp = false 
local isSyncLoop = false  
local IsTeleporting = false

-- // ==================== RESOLVER SYSTEM (NEXT GEN PREDICTION) ==================== //
getgenv().Resolver = {
    Enabled = true,
    LookAhead = 0.235, -- 200ms prediction
    Cache = {},
    Marker = nil
}

-- Create Marker
task.spawn(function()
    local marker = Instance.new("Part")
    marker.Name = "ResolverMarker"
    marker.Size = Vector3.new(1, 1, 1)
    marker.Anchored = true
    marker.CanCollide = false
    marker.Transparency = 0.6
    marker.Color = Color3.fromRGB(255, 0, 0)
    marker.Material = Enum.Material.Neon
    marker.Shape = Enum.PartType.Ball
    marker.Parent = Workspace
    getgenv().Resolver.Marker = marker
    
    -- Cleanup if script closes
    -- We bind cleanup later in Close!
end)

-- Resolver Logic Loop (Calculates custom velocity)
RunService.Heartbeat:Connect(function(dt)
    if not getgenv().Resolver.Enabled then return end
    
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = plr.Character.HumanoidRootPart
            local id = plr.UserId
            
            if not getgenv().Resolver.Cache[id] then
                getgenv().Resolver.Cache[id] = {
                    LastPos = hrp.Position,
                    Velocity = Vector3.zero
                }
            else
                local data = getgenv().Resolver.Cache[id]
                local displacement = hrp.Position - data.LastPos
                
                -- Check for teleport (sudden huge movement)
                if displacement.Magnitude > 20 then
                    data.Velocity = Vector3.zero -- Reset on teleport
                else
                    -- Calculate real velocity manually
                    if dt > 0 then
                        data.Velocity = displacement / dt
                    end
                end
                
                data.LastPos = hrp.Position
            end
        end
    end
end)


local function GetResolverPrediction(targetPart)
    if not targetPart or not targetPart.Parent then return targetPart.Position end
    local plr = Players:GetPlayerFromCharacter(targetPart.Parent)
    if not plr then return targetPart.Position end -- Fallback for NPCs
    
    local data = getgenv().Resolver.Cache[plr.UserId]
    local predPos = targetPart.Position
    
    -- ** UPDATED: Enhanced Combat Prediction Math **
    local useCombatMath = (isKnockMode or isStompMode or isLoopMode)
    
    if data then
        local velocity = data.Velocity
        
        -- Fix NaN/Infinite velocity crashes
        if velocity.X ~= velocity.X or velocity.Y ~= velocity.Y or velocity.Z ~= velocity.Z then
            velocity = Vector3.zero
        end
        
        if useCombatMath then
            -- Apply Resolver Config: Forgiveness, Bonus, DistancePenalty
            local settings = getgenv().CombatSettings.Resolver
            local predSettings = getgenv().CombatSettings.Prediction
            
            -- Basic Calculation with multiplier
            local basePred = predSettings.Base -- 0.02
            local mult = predSettings.Multiplier -- 1.8x
            
            -- Distance Penalty Logic
            local dist = (LocalPlayer.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
            local penalty = dist > 50 and settings.DistancePenalty or 1
            
            -- Apply Math
            predPos = targetPart.Position + (velocity * (basePred + (mult * penalty))) + Vector3.new(0, settings.Bonus / 100, 0) 
            
        else
            -- Standard 200ms prediction
            predPos = targetPart.Position + (data.Velocity * getgenv().Resolver.LookAhead)
        end
    else
        -- Fallback to standard velocity if cache miss
        predPos = targetPart.Position + (targetPart.Velocity * getgenv().Resolver.LookAhead)
    end
    
    -- Safety Check for NaN
    if predPos.X ~= predPos.X then return targetPart.Position end

    -- Update Marker
    if getgenv().Resolver.Marker then
        getgenv().Resolver.Marker.CFrame = CFrame.new(predPos)
    end
    
    return predPos
end

-- // =============================================================================== //

-- Safe Remote Reference
local MainEvent = ReplicatedStorage:WaitForChild("MainEvent", 10)
if not MainEvent then
    warn("CRITICAL: MainEvent not found. Waiting indefinitely or until it appears...")
    MainEvent = ReplicatedStorage:WaitForChild("MainEvent")
end

-- // ==================== CONFIGURATION ==================== //
-- Ensure OWNER_NAME is defined, or it defaults to LocalPlayer for testing
if not getgenv().OWNER_NAME then getgenv().OWNER_NAME = game:GetService("Players").LocalPlayer.Name end

-- // =================================================================================== //
-- //       V A N T A   //   W I N T E R   S I N G U L A R I T Y   //   U L T R A     //
-- // =================================================================================== //

local CONFIG = {
    Title = "VANTA - V0.7", -- [UPDATED to V0.7]
    Subtitle = "SYSTEM INTEGRATION: WINTER_PROTOCOL",
    Assets = {
        SantaHat = "rbxassetid://13545166299", -- Overlay for Avatar
        SnowTexture = "rbxassetid://6023426915"
    },
    Theme = {
        Background = Color3.fromRGB(8, 10, 15),     -- Deep Vanta Blue
        Accent     = Color3.fromRGB(0, 255, 240),   -- Neon Cyan
        Secondary  = Color3.fromRGB(80, 140, 255),  -- Frost Blue
        Text       = Color3.fromRGB(245, 245, 255),
        BarGradient = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 100, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
        }
    }
}

local VirtualUser = game:GetService('VirtualUser')
 
game:GetService('Players').LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)
 
game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AntiAFK",
    Text = "Loaded.",
    Duration = 5
})

-- Cleanup Old UI
pcall(function() 
    if CoreGui:FindFirstChild("VantaWinterUltra") then
        CoreGui.VantaWinterUltra:Destroy()
    elseif LocalPlayer.PlayerGui:FindFirstChild("VantaWinterUltra") then
        LocalPlayer.PlayerGui.VantaWinterUltra:Destroy()
    end
end)

-- // [1] UI LIBRARY
local Lib = {}

function Lib:Create(class, props, children)
    local obj = Instance.new(class)
    for k, v in pairs(props) do obj[k] = v end
    if children then for _, c in pairs(children) do c.Parent = obj end end
    return obj
end

function Lib:Tween(obj, info, props)
    local t = TweenService:Create(obj, info, props)
    t:Play()
    return t
end

function Lib:MakeDraggable(frame)
    local dragging, dragInput, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            Lib:Tween(frame, TweenInfo.new(0.05), {
                Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            })
        end
    end)
end

function Lib:GlassPanel(props)
    local frame = Lib:Create("Frame", {
        BackgroundColor3 = Color3.fromRGB(15, 20, 30),
        BackgroundTransparency = 0.2,
        BorderSizePixel = 0,
        ClipsDescendants = true
    })
    for k, v in pairs(props) do frame[k] = v end
    
    Lib:Create("UICorner", {CornerRadius = UDim.new(0, 8), Parent = frame})
    Lib:Create("UIStroke", {Color = CONFIG.Theme.Secondary, Transparency = 0.6, Thickness = 1, Parent = frame})
    Lib:Create("UIGradient", {
        Rotation = 45,
        Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1, Color3.fromRGB(100,100,100))},
        Parent = frame
    })
    return frame
end

-- // [2] MAIN STRUCTURE
local ScreenParent = CoreGui
-- Fallback for executors blocking CoreGui
if not pcall(function() local x = CoreGui.Name end) then
    ScreenParent = LocalPlayer:WaitForChild("PlayerGui")
end

local Screen = Lib:Create("ScreenGui", {
    Name = "VantaWinterUltra",
    Parent = ScreenParent,
    IgnoreGuiInset = true,
    DisplayOrder = 10000
})

-- Background (Starts Transparent for Fade In)
local Background = Lib:Create("Frame", {
    Name = "Background",
    Size = UDim2.fromScale(1, 1),
    BackgroundColor3 = CONFIG.Theme.Background,
    BackgroundTransparency = 1, -- Fade logic
    ZIndex = 0,
    Parent = Screen
})

-- Gradient Overlay for Atmosphere
Lib:Create("UIGradient", {
    Color = ColorSequence.new(CONFIG.Theme.Background, Color3.fromRGB(20, 30, 50)),
    Rotation = 90,
    Parent = Background
})

-- Snow Container (Behind Loader, Front of BG)
local SnowLayer = Lib:Create("Frame", {
    Size = UDim2.fromScale(1, 1),
    BackgroundTransparency = 1,
    ZIndex = 5,
    Parent = Screen
})

-- // [3] LOADER UI
local Loader = Lib:Create("Frame", {
    Name = "Loader",
    Size = UDim2.fromScale(1, 1),
    BackgroundTransparency = 1,
    ZIndex = 100,
    Parent = Screen
})

local CenterFrame = Lib:Create("Frame", {
    Size = UDim2.fromOffset(500, 350),
    Position = UDim2.fromScale(0.5, 0.5),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundTransparency = 1,
    Parent = Loader
})

-- Avatar Circle
local AvatarHalo = Lib:Create("Frame", {
    Size = UDim2.fromOffset(130, 130),
    Position = UDim2.fromScale(0.5, 0.2),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = CONFIG.Theme.Background,
    BackgroundTransparency = 1, -- Start invisible
    Parent = CenterFrame
}, {
    Lib:Create("UICorner", {CornerRadius = UDim.new(1, 0)}),
    Lib:Create("UIStroke", {Color = CONFIG.Theme.Accent, Thickness = 2, Transparency = 1}) -- Start invisible
})

local UserImg = Lib:Create("ImageLabel", {
    Parent = AvatarHalo,
    Size = UDim2.fromScale(1, 1),
    BackgroundTransparency = 1,
    Image = Players:GetUserThumbnailAsync(LocalPlayer.UserId, Enum.ThumbnailType.AvatarBust, Enum.ThumbnailSize.Size420x420),
    ImageTransparency = 1 -- Start invisible
}, { Lib:Create("UICorner", {CornerRadius = UDim.new(1, 0)}) })

-- Christmas Hat
local Hat = Lib:Create("ImageLabel", {
    Parent = AvatarHalo,
    Size = UDim2.fromOffset(100, 100),
    Position = UDim2.new(0, -30, 0, -45),
    BackgroundTransparency = 1,
    Image = CONFIG.Assets.SantaHat,
    ImageTransparency = 1,
    ZIndex = 10
})

-- Title
local MainTitle = Lib:Create("TextLabel", {
    Parent = CenterFrame,
    Text = CONFIG.Title,
    Font = Enum.Font.GothamBlack,
    TextSize = 36,
    TextColor3 = CONFIG.Theme.Text,
    Position = UDim2.fromScale(0.5, 0.5),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundTransparency = 1,
    TextTransparency = 1
}, {
    Lib:Create("UIStroke", {Thickness = 1, Transparency = 1})
})

-- Loading Bar Container
local BarContainer = Lib:Create("Frame", {
    Parent = CenterFrame,
    Size = UDim2.fromOffset(0, 8), -- Start width 0
    Position = UDim2.fromScale(0.5, 0.7),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Color3.fromRGB(20, 25, 35),
    BackgroundTransparency = 1
}, { Lib:Create("UICorner", {CornerRadius = UDim.new(1,0)}) })

-- The Actual Bar
local BarFill = Lib:Create("Frame", {
    Parent = BarContainer,
    Size = UDim2.fromScale(0, 1),
    BackgroundColor3 = Color3.new(1,1,1)
}, {
    Lib:Create("UICorner", {CornerRadius = UDim.new(1,0)}),
    Lib:Create("UIGradient", {Color = CONFIG.Theme.BarGradient})
})

-- Status Text
local StatusText = Lib:Create("TextLabel", {
    Parent = CenterFrame,
    Text = "INITIALIZING...",
    Font = Enum.Font.Code,
    TextSize = 14,
    TextColor3 = CONFIG.Theme.Secondary,
    Position = UDim2.fromScale(0.5, 0.8),
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundTransparency = 1,
    TextTransparency = 1
})

-- // [4] HUD UI (Hidden initially)
local HUD = Lib:Create("Frame", {
    Name = "HUD",
    Parent = Screen,
    Size = UDim2.fromScale(1, 1),
    BackgroundTransparency = 1,
    Visible = false,
    ZIndex = 50
})

--[[
    -- SERVER LOGS REMOVED PER REQUEST --
local ChatPanel = Lib:GlassPanel({Parent = HUD, Size = UDim2.fromOffset(400, 250), Position = UDim2.new(0, 30, 0.5, -125)})
Lib:MakeDraggable(ChatPanel)

local ChatScroll = Lib:Create("ScrollingFrame", {
    Parent = ChatPanel, Size = UDim2.new(1, -10, 1, -30), Position = UDim2.new(0, 5, 0, 25),
    BackgroundTransparency = 1, ScrollBarThickness = 2, ScrollBarImageColor3 = CONFIG.Theme.Accent,
    AutomaticCanvasSize = "Y", CanvasSize = UDim2.new(0,0,0,0)
})
Lib:Create("UIListLayout", {Parent = ChatScroll, SortOrder = "LayoutOrder", Padding = UDim.new(0, 4)})
Lib:Create("TextLabel", {Parent=ChatPanel, Text=" // SERVER LOGS", Font=Enum.Font.GothamBold, TextColor3=CONFIG.Theme.Accent, TextSize=12, Size=UDim2.new(1,0,0,25), Position=UDim2.fromOffset(10,0), BackgroundTransparency=1, TextXAlignment="Left"})
]]

local StatsPanel = Lib:GlassPanel({Parent = HUD, Size = UDim2.fromOffset(200, 90), Position = UDim2.new(1, -230, 1, -120)})
Lib:MakeDraggable(StatsPanel)

-- // [5] SNOW ENGINE (Physics + Visuals)
local Snowflakes = {}
local MAX_SNOW = 200

local function SpawnSnow()
    if #Snowflakes >= MAX_SNOW then return end
    
    local depth = math.random(3, 10) / 10 -- Depth determines size and speed
    local size = math.random(2, 5) * depth
    
    local f = Lib:Create("Frame", {
        Parent = SnowLayer,
        Size = UDim2.fromOffset(size, size),
        Position = UDim2.fromScale(math.random(), -0.1),
        BackgroundColor3 = Color3.new(1,1,1),
        BackgroundTransparency = math.clamp(1.1 - depth, 0.2, 0.9), -- Further snow is fainter
        BorderSizePixel = 0
    }, { Lib:Create("UICorner", {CornerRadius = UDim.new(1,0)}) })

    table.insert(Snowflakes, {
        Obj = f,
        Speed = (math.random(20, 60)/10000) * depth,
        Sway = math.random(1, 15)/5000,
        Freq = math.random(2, 6),
        Phase = math.random(0, 100)
    })
end

RunService.RenderStepped:Connect(function()
    SpawnSnow()
    local t = tick()
    
    -- Update Snow
    for i = #Snowflakes, 1, -1 do
        local s = Snowflakes[i]
        if s.Obj.Parent then
            local y = s.Obj.Position.Y.Scale + s.Speed
            local x = s.Obj.Position.X.Scale + (math.sin(t * s.Freq + s.Phase) * s.Sway)
            s.Obj.Position = UDim2.fromScale(x, y)
            if y > 1.1 then
                s.Obj:Destroy()
                table.remove(Snowflakes, i)
            end
        else
            table.remove(Snowflakes, i)
        end
    end
    
    -- Animate Bar Gradient (Shimmer)
    if Loader.Visible then
        local offset = (math.sin(t * 2) + 1) / 2 -- 0 to 1
        -- Subtle rotation of gradient could go here
    end
end)

-- // [6] CHAT LOGIC (Disabled/Empty)
local function AddLog(name, msg)
    -- Disabled
end

-- // [7] STATS LOGIC
task.spawn(function()
    local FPS = Lib:Create("TextLabel", {Parent=StatsPanel, Text="FPS: ..", Font=Enum.Font.Code, TextColor3=Color3.new(1,1,1), BackgroundTransparency=1, Position=UDim2.fromOffset(10,10), Size=UDim2.new(1,-20,0,20), TextXAlignment="Left"})
    local PING = Lib:Create("TextLabel", {Parent=StatsPanel, Text="PING: ..", Font=Enum.Font.Code, TextColor3=Color3.new(1,1,1), BackgroundTransparency=1, Position=UDim2.fromOffset(10,35), Size=UDim2.new(1,-20,0,20), TextXAlignment="Left"})
    
    while true do
        if HUD.Visible then
            FPS.Text = "FPS: " .. math.floor(workspace:GetRealPhysicsFPS())
            PING.Text = "PING: " .. math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()) .. "ms"
        end
        task.wait(1)
    end
end)

-- // [8] CINEMATIC SEQUENCE (The Fix)
task.spawn(function()
    -- PHASE 1: Immediate Wake (Fixes Black Screen)
    Lib:Tween(Background, TweenInfo.new(1), {BackgroundTransparency = 0}) -- Fade BG in smoothly
    
    task.wait(1) -- Pause to let user settle
    
    -- PHASE 2: Visual Elements Pop
    -- Pop Avatar
    AvatarHalo.Size = UDim2.fromScale(0,0)
    AvatarHalo.BackgroundTransparency = 0
    Lib:Tween(AvatarHalo, TweenInfo.new(1, Enum.EasingStyle.Elastic), {Size = UDim2.fromOffset(130, 130)})
    Lib:Tween(AvatarHalo.UIStroke, TweenInfo.new(0.5), {Transparency = 0})
    
    task.wait(0.5)
    Lib:Tween(UserImg, TweenInfo.new(0.5), {ImageTransparency = 0})
    Lib:Tween(Hat, TweenInfo.new(0.5, Enum.EasingStyle.Back), {ImageTransparency = 0, Position = UDim2.new(0, -30, 0, -45)})
    
    task.wait(0.8)
    
    -- Pop Title & Bar Container
    Lib:Tween(MainTitle, TweenInfo.new(0.5), {TextTransparency = 0, Position = UDim2.fromScale(0.5, 0.45)})
    Lib:Tween(BarContainer, TweenInfo.new(0.8, Enum.EasingStyle.Quart), {Size = UDim2.fromOffset(400, 8), BackgroundTransparency = 0})
    Lib:Tween(StatusText, TweenInfo.new(0.5), {TextTransparency = 0})
    
    task.wait(0.5)
    
    -- PHASE 3: The Loading Simulation (Slow & Smooth)
    local steps = {
        {pct = 0.2, text = "LOADING_ASSETS_PACK_1..."},
        {pct = 0.45, text = "CONNECTING_TO_WINTER_NET..."},
        {pct = 0.60, text = "DECRYPTING_SNOW_PHYSICS..."},
        {pct = 0.85, text = "BYPASSING_SECURITY_LAYER..."},
        {pct = 1.0, text = "WELCOME_USER."}
    }
    
    for _, step in ipairs(steps) do
        -- Update Text
        StatusText.Text = step.text
        StatusText.TextColor3 = Color3.new(1,1,1) -- Flash white
        Lib:Tween(StatusText, TweenInfo.new(0.3), {TextColor3 = CONFIG.Theme.Secondary})
        
        -- Smooth Bar Tween
        local duration = math.random(15, 25) / 10 -- 1.5 to 2.5 seconds per step
        Lib:Tween(BarFill, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Size = UDim2.fromScale(step.pct, 1)})
        
        task.wait(duration)
    end
    
    task.wait(0.5)
    
    -- PHASE 4: Transition to HUD
    -- Slide Loader Up
    Lib:Tween(CenterFrame, TweenInfo.new(1, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.fromScale(0.5, -0.5)})
    
    -- Fade out Background (But keep snow momentarily?)
    Lib:Tween(Background, TweenInfo.new(1), {BackgroundTransparency = 1})
    
    task.wait(0.8)
    Loader.Visible = false
    HUD.Visible = true
    
    -- Animate HUD Panels In
    -- ChatPanel Removed
    StatsPanel.Size = UDim2.fromOffset(0,0)
    
    -- Lib:Tween(ChatPanel, TweenInfo.new(0.6, Enum.EasingStyle.Back), {Size = UDim2.fromOffset(400, 250)})
    task.wait(0.1)
    Lib:Tween(StatsPanel, TweenInfo.new(0.6, Enum.EasingStyle.Back), {Size = UDim2.fromOffset(200, 90)})
    
    -- Anti AFK
    if game:GetService("VirtualUser") then
        game:GetService("VirtualUser"):CaptureController()
        game:GetService("VirtualUser"):ClickButton2(Vector2.new())
    end
end)

-- ==================== CONFIGURATION ====================

local Stand = {
    IsActive = false,
    IsTargeting = false,
    OwnerPlayer = nil,
    FollowTarget = nil, 
    FollowConnection = nil,
    TargetConnection = nil,
    TargetPlayer = nil,
    Offset = Vector3.new(-3, 4, 4) 
}

-- UPDATED WEAPON CONFIG: AUG REPLACES FLINTLOCK
local WeaponConfig = {
    rifle = {
        toolName = "[Rifle]",
        shopNamePartial = "[Rifle]", 
        ammoShopNamePartial = "[Rifle Ammo]"
    },
    aug = {
        toolName = "[AUG]",
        shopNamePartial = "[AUG]", -- Searches for partial string, ignores price
        ammoShopNamePartial = "[AUG Ammo]"
    }
}

local AutoBuy = {
    isBuying = false,
    isEquipping = false
}

-- ADAPTIVE DELAY SYSTEM
getgenv().AdaptiveDelays = {
    Rifle = 0.15,
    Aug = 0.15,
    Armor = 0.15,
    Ammo = 0.15,
    FireArmor = 0.15 -- Added FireArmor delay
}

local CombatTarget = nil
local isShooting = false
local isIdle = true
local isBuying = false
local isBuyingGun = false
local isGrabMode = false
-- isKnockMode, isStompMode, isLoopMode defined earlier
local isVoidSpam = false 
local isUndergroundAttack = false 
local isFlinging = false 
local isAutoFling = false 
local AutoFlingTarget = nil 
local isFlamethrowerStick = false
local isFlamethrowerLoop = false

local BaitRunning = false

local CombatResume = {
    Active = false,
    Mode = nil,
    Target = nil
}

local AutoSaveEnabled = false
local isSavingOwner = false

local FadeConnection = nil
local grabbingConnection = nil
local UndergroundConnection = nil
local FlingConnection = nil 
local AutoFlingLoop = nil 
local FlamethrowerConnection = nil


-- ==================== CRITICAL HELPER FUNCTIONS ====================

local function ToggleWallet(show)
    local char = LocalPlayer.Character
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not char or not backpack then return end
    
    if show then
        local wallet = backpack:FindFirstChild("[Wallet]")
        if wallet then
            wallet.Parent = char
        end
    else
        local wallet = char:FindFirstChild("[Wallet]")
        if wallet then
            wallet.Parent = backpack
        end
    end
end

local function IsTargetKO(char)
    if not char then return false end
    
    local be = char:FindFirstChild("BodyEffects")
    if not be then return false end
    
    local koVal = be:FindFirstChild("K.O")
    if koVal and koVal.Value == true then 
        return true 
    end
    
    local hum = char:FindFirstChild("Humanoid")
    if hum and hum.Health <= 3 and hum.Health > 0 then 
        return true 
    end
    
    if char:FindFirstChild("GRABBING_CONSTRAINT") then
        return true
    end

    return false
end

local function IsTargetDead(char)
    if not char then return true end
    
    local hum = char:FindFirstChild("Humanoid")
    local be = char:FindFirstChild("BodyEffects")
    
    if hum and hum.Health <= 0 then
        return true
    end
    
    if be then
        local deadVal = be:FindFirstChild("Dead")
        if deadVal and deadVal.Value == true then
            return true
        end
        
        local stompedVal = be:FindFirstChild("Stomped")
        if stompedVal and stompedVal.Value == true then
            return true
        end
    end
    
    return false
end

local function HasForceField(char)
    if not char then return false end
    if char:FindFirstChildOfClass("ForceField") then
        return true
    end
    return false
end

local function GetCharParts(player)
    if not player or not player.Character then return nil, nil end
    return player.Character:FindFirstChild("HumanoidRootPart"), player.Character:FindFirstChild("Humanoid")
end

local function FindShopItem(partialName)
    local ignored = workspace:FindFirstChild("Ignored")
    if not ignored then return nil end
    local shop = ignored:FindFirstChild("Shop")
    if not shop then return nil end

    for _, item in ipairs(shop:GetChildren()) do
        if item.Name:find(partialName, 1, true) then
            return item
        end
    end
    return nil
end

-- UPDATED: GetPredictedPosition NOW USES RESOLVER
local function GetPredictedPosition(targetPart, time)
    -- This function overrides the old simple calculation with the new Resolver
    if not targetPart then return Vector3.zero end
    
    if getgenv().Resolver and getgenv().Resolver.Enabled then
        return GetResolverPrediction(targetPart)
    else
        -- Fallback if resolver disabled
        return targetPart.Position + (targetPart.Velocity * time)
    end
end

-- ==================== AUTO-BUY PAUSE/RESUME LOGIC ====================

local function PauseCombatForBuy()
    if isLoopMode then
        CombatResume = {Active=true, Mode="loop", Target=CombatTarget}
    elseif isStompMode then
        CombatResume = {Active=true, Mode="stomp", Target=CombatTarget}
    elseif isKnockMode then
        CombatResume = {Active=true, Mode="knock", Target=CombatTarget}
    elseif isGrabMode then
        CombatResume = {Active=true, Mode="grab", Target=CombatTarget}
    elseif isUndergroundAttack then
        CombatResume = {Active=true, Mode="underground", Target=CombatTarget}
    else
        CombatResume = {Active=false}
    end

    if CombatResume.Active then
        print("[AutoBuy] Pausing combat mode (" .. CombatResume.Mode .. ") for purchase...")
    end

    isLoopMode = false
    isStompMode = false
    isKnockMode = false
    isGrabMode = false
    isUndergroundAttack = false
    isShooting = false
    Stand.IsActive = false
    isFlinging = false 
    isAutoFling = false 
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false
    
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
end

local function ResumeCombatAfterBuy()
    if not CombatResume.Active or not CombatResume.Target then
        Stand:Fade()
        return
    end

    local target = CombatResume.Target
    if not target or not target.Parent then
        print("[AutoBuy] Target left during purchase. Fading.")
        Stand:Fade()
        CombatResume = {Active=false}
        return
    end

    print("[AutoBuy] Resuming " .. CombatResume.Mode .. " on " .. target.Name)
    
    CombatTarget = target
    isIdle = false

    if CombatResume.Mode == "loop" then
        isLoopMode = true
        isShooting = true
    elseif CombatResume.Mode == "stomp" then
        isStompMode = true
        isShooting = true
    elseif CombatResume.Mode == "knock" then
        isKnockMode = true
        isShooting = true
    elseif CombatResume.Mode == "grab" then
        isGrabMode = true
    elseif CombatResume.Mode == "underground" then
        isUndergroundAttack = true
        if ActivateUndergroundAttack then
             ActivateUndergroundAttack(target)
        end
    end
    
    CombatResume = {Active=false}
end


-- ==================== ANTI-VOID SYSTEM ====================

local AntiVoidEnabled = true
local AntiVoidHRP = nil
pcall(function()
    if LocalPlayer.Character then
        AntiVoidHRP = LocalPlayer.Character:WaitForChild("HumanoidRootPart", 5)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(newChar)
    AutoBuy.isBuying = false
    isBuying = false
    isBuyingGun = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false 
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false
    
    AntiVoidHRP = newChar:WaitForChild("HumanoidRootPart", 5)
    task.delay(1.5, function()
        if ScriptRunning and not isBuying and not IsTeleporting and not isSavingOwner then
             print("[Respawn] Character reset, returning to mode...")
             if isAutoFling and AutoFlingTarget then
                 print("[Respawn] Resuming AutoFling...")
             else
                 -- MODIFIED: Default to Fade to prevent auto-following
                 Stand:Fade()
             end
        end
    end)
end)

-- ==============================================================================
--                            NEXTGEN FAKE POSITION
-- ==============================================================================

local FLAG_NAME = "NextGenReplicatorEnabledWrite4"

-- State management to prevent command spamming
local isBusy = false

-- ==================== UTILITIES ====================

local function notify(title, text, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title;
            Text = text;
            Duration = duration or 3;
            Icon = "rbxassetid://12812846841"; -- Optional generic icon
        })
    end)
end

local function setFlagSafely(flagName, value)
    -- Support for multiple executor function names
    local setFlagFunc = setfflag or set_fast_flag or (function() end)
    
    if type(setFlagFunc) ~= "function" then
        warn("[FP] Your executor does not support setfflag/set_fast_flag.")
        return false
    end

    local success, err = pcall(function()
        setFlagFunc(flagName, tostring(value))
    end)

    if not success then
        warn("[FP] Flag Error: " .. tostring(err))
        return false
    end
    return true
end

local function killCharacter()
    local char = LocalPlayer.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.Health = 0
            return true
        end
    end
    return false
end

local function waitForRespawn(timeout)
    timeout = timeout or 10
    local startTime = tick()

    -- 1. Wait for the Character object
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    
    -- 2. Wait for the Character to be parented to Workspace (fully loaded)
    while not char.Parent do
        if tick() - startTime > timeout then return nil end
        RunService.Heartbeat:Wait()
    end

    -- 3. Wait for critical components
    local hum = char:WaitForChild("Humanoid", timeout)
    local root = char:WaitForChild("HumanoidRootPart", timeout)

    if not hum or not root then return nil end

    return char
end

-- ==================== COMMAND HANDLERS ====================

local function handleFpCommand()
    if isBusy then 
        notify("FP System", "System is busy. Please wait.")
        return 
    end
    isBusy = true

    notify("Fake Position", "Enabling... (Respawning)", 2)
    print("[FP] Initiating activation sequence...")

    task.spawn(function()
        -- 1. Kill the player
        killCharacter()

        -- 2. Wait for the new character to exist and be ready
        local newChar = waitForRespawn(10) -- 10s timeout

        if not newChar then
            warn("[FP] Timed out waiting for respawn.")
            notify("Fake Position", "Failed: Respawn Timeout", 5)
            isBusy = false
            return
        end

        print("[FP] Character loaded. Synchronizing...")

        -- 3. Physics Stabilization
        -- Wait for 2 physics frames to ensure the server recognizes the spawn
        RunService.Stepped:Wait()
        RunService.Stepped:Wait()

        -- 4. Enable the Flag
        local success = setFlagSafely(FLAG_NAME, "true")

        if success then
            print("[FP] SUCCESS: Flag enabled.")
            notify("Fake Position", "ENABLED (Desync Active)", 4)
        else
            notify("Fake Position", "Failed to set flag.", 4)
        end
        
        isBusy = false
    end)
end

local function handleUnfpCommand()
    if isBusy then 
        notify("FP System", "System is busy. Please wait.")
        return 
    end
    isBusy = true

    print("[FP] Disabling...")
    notify("Fake Position", "Disabling...", 2)

    task.spawn(function()
        -- 1. Disable the flag FIRST
        -- We do this before killing so the server processes the death event correctly
        -- with standard replication protocols.
        local success = setFlagSafely(FLAG_NAME, "false")

        -- 2. Slight delay to ensure flag change registers internally
        task.wait(0.1)

        -- 3. Kill to reset position/sync
        killCharacter()
        
        -- 4. Wait for respawn (optional, just to clear busy status)
        waitForRespawn(10)

        if success then
            print("[FP] SUCCESS: Flag disabled.")
            notify("Fake Position", "DISABLED (Resync Complete)", 3)
        else
            notify("Error", "Could not disable flag.", 3)
        end

        isBusy = false
    end)
end

-- ==================== VELOCITY BREAKER LOOP (vb!) ====================
task.spawn(function()
    RunService.Heartbeat:Connect(function()
        if getgenv().VelocityBreaker and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local mult = getgenv().VelocityBreakerConfig.Multiplier
            -- Reverse Velocity Logic
            hrp.AssemblyLinearVelocity = -hrp.AssemblyLinearVelocity * mult
        end
    end)
end)

task.spawn(function()
    while ScriptRunning do
        if AntiVoidEnabled and
           not isBuying and
           not isBuyingGun and
           not AutoBuy.isBuying and 
           not isKnockMode and
           not isGrabMode and
           not isStompMode and
           not isLoopMode and
           not isVoidSpam and 
           not IsTeleporting and 
           not isSavingOwner and 
           not isUndergroundAttack and 
           not isFlinging and
           not isAutoFling and
           not isSyncStomp and
           not isSyncLoop and
           not isFlamethrowerStick and
           not isFlamethrowerLoop and
           not Stand.IsActive and
           not FadeConnection then
            pcall(function()
                if AntiVoidHRP and AntiVoidHRP.Parent then
                    AntiVoidHRP.CFrame = CFrame.new(
                        math.random(-999999, 999999),
                        math.random(2000, 10000),
                        math.random(-999999, 999999)
                    )
                    AntiVoidHRP.Velocity = Vector3.zero
                    AntiVoidHRP.RotVelocity = Vector3.zero
                else
                    local char = LocalPlayer.Character
                    if char then AntiVoidHRP = char:FindFirstChild("HumanoidRootPart") end
                end
            end)
        end
        task.wait(0.2)
    end
end)

pcall(function()
    workspace.FallenPartsDestroyHeight = 0/0
end)

pcall(function()
    setfflag("S2PhysicsSenderRate", 1.0E20)
end)

print("[AntiVoid] Enabled - Void death disabled")

-- ==================== ANTI-SIT SYSTEM ====================

task.spawn(function()
    pcall(function()
        for _, seat in ipairs(Workspace:GetDescendants()) do
            if seat:IsA("Seat") and not IsTeleporting then 
                seat:Destroy()
            end
        end
    end)

    Workspace.DescendantAdded:Connect(function(descendant)
        task.defer(function()
            if IsTeleporting then return end 

            if descendant:IsA("Seat") then
                pcall(function()
                    descendant:Destroy()
                end)
            end
        end)
    end)

    print("[AntiSit] Enabled - All seats destroyed")
end)

-- ==================== GENERAL UTILITY FUNCTIONS ====================

-- ==================== MAIN STRAFE SYSTEM (INTEGRATED) ====================

function Stand:FindOwner()
    local owner = Players:FindFirstChild(OwnerUsername)
    if owner then
        Stand.OwnerPlayer = owner
        Stand.FollowTarget = nil
        return owner
    end
    return nil
end

function Stand:Resume()
    print("[Stand] Resuming duty (Returning to Owner)...")
    CombatTarget = nil
    isShooting = false
    isIdle = true
    isKnockMode = false
    isGrabMode = false
    isStompMode = false
    isLoopMode = false
    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false
    AutoFlingTarget = nil
    BaitRunning = false 
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false
    
    Stand:Call()
end

function Stand:GetStandParts()
    local char = LocalPlayer.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        return hrp, humanoid
    end
    return nil, nil
end

function Stand:FindTargetPlayer(query)
    if not query then return nil end
    query = query:lower()
    
    local exact = Players:FindFirstChild(query)
    if exact then return exact end
    
    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()
        if name:find(query, 1, true) or displayName:find(query, 1, true) then
            return player
        end
    end
    return nil
end

local function reloadTool()
    pcall(function()
        local Character = LocalPlayer.Character
        if Character then
            for _, tool in ipairs(Character:GetChildren()) do
                if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
                    MainEvent:FireServer("Reload", tool)
                end
            end
        end
    end)
end

local function UnequipTools()
    pcall(function()
        local Character = LocalPlayer.Character
        local Backpack = LocalPlayer:FindFirstChild("Backpack")
        if Character and Backpack then
            for _, tool in ipairs(Character:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = Backpack
                end
            end
        end
    end)
end

task.spawn(function()
    while task.wait(0.5) do
        local char = LocalPlayer.Character
        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").Health <= 5 then
             char:FindFirstChildOfClass("Humanoid").Health = 0
        end
    end
end)

-- ==================== AUTO-BUY WEAPON SYSTEM (UPDATED ADAPTIVE DELAY) ====================

local function getAmmoCount(weaponName)
    local success, result = pcall(function()
        local dataFolder = LocalPlayer:FindFirstChild("DataFolder")
        if not dataFolder then return nil end
        local inventory = dataFolder:FindFirstChild("Inventory")
        if not inventory then return nil end
        local ammoData = inventory:FindFirstChild(weaponName)
        if ammoData and ammoData.Value then
            return tonumber(ammoData.Value)
        end
        return nil
    end)
    if success and result then
        return result
    end
    return nil
end

local function hasGun(gunName)
    local Character = LocalPlayer.Character
    local Backpack = LocalPlayer:FindFirstChild("Backpack")

    if Backpack then
        for _, tool in ipairs(Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == gunName then
                return true
            end
        end
    end

    if Character then
        for _, tool in ipairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == gunName then
                return true
            end
        end
    end

    return false
end

-- Update Buy Function with Adaptive Delay
local function buyWeapon(weaponType)
    if AutoBuy.isBuying or not ScriptRunning then
        return
    end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end
    
    PauseCombatForBuy()

    AutoBuy.isBuying = true
    isBuyingGun = true

    local config = WeaponConfig[weaponType]
    if not config then
        AutoBuy.isBuying = false
        isBuyingGun = false
        return
    end

    print("[AutoBuy] Purchasing " .. config.toolName)

    pcall(function()
        local Character = LocalPlayer.Character
        if not Character then return end

        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChild("Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then return end

        local shopItem = FindShopItem(config.shopNamePartial)
        if not shopItem then
            print("[AutoBuy] Shop item not found for: " .. config.toolName)
            return
        end

        local ClickDetector = shopItem:FindFirstChild("ClickDetector")
        if not ClickDetector then return end

        local shopHead = shopItem:FindFirstChild("Head")
        if not shopHead then return end

        UnequipTools()
        task.wait(0.05)

        local attempts = 0
        local maxAttempts = 30
        
        -- Get Delay key (Capitalize first letter)
        local delayKey = weaponType:gsub("^%l", string.upper)
        if not getgenv().AdaptiveDelays[delayKey] then delayKey = "Rifle" end -- fallback

        while not hasGun(config.toolName) and attempts < maxAttempts and ScriptRunning do
            Character = LocalPlayer.Character
            if not Character then break end

            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            Humanoid = Character:FindFirstChild("Humanoid")
            if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then break end

            local currentDelay = getgenv().AdaptiveDelays[delayKey]

            -- 1. Teleport to Head
            HumanoidRootPart.CFrame = CFrame.new(shopHead.CFrame.Position + Vector3.new(0, 3, 0))
            HumanoidRootPart.Velocity = Vector3.zero
            task.wait(currentDelay) -- Adaptive Wait

            -- 2. Fire ClickDetector
            pcall(function() fireclickdetector(ClickDetector) end)

            -- 3. Teleport to Void
            HumanoidRootPart.CFrame = CFrame.new(0, -10000000, 0)
            HumanoidRootPart.Velocity = Vector3.zero
            task.wait(0.2)

            attempts = attempts + 1
            if hasGun(config.toolName) then
                print("[AutoBuy] Successfully purchased " .. config.toolName)
                -- Decrease delay on success (make it faster next time)
                getgenv().AdaptiveDelays[delayKey] = math.max(0.05, currentDelay - 0.05)
                break
            else
                -- Increase delay on fail
                getgenv().AdaptiveDelays[delayKey] = currentDelay + 0.1
                -- print("Buy Failed. Increased delay to: " .. getgenv().AdaptiveDelays[delayKey])
            end
        end
    end)

    task.wait(0.1)
    AutoBuy.isBuying = false
    isBuyingGun = false
    
    ResumeCombatAfterBuy()
end

local function buyAmmo(weaponType)
    if AutoBuy.isBuying or not ScriptRunning then
        return
    end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    PauseCombatForBuy()

    AutoBuy.isBuying = true
    isBuying = true

    local config = WeaponConfig[weaponType]
    if not config then
        AutoBuy.isBuying = false
        isBuying = false
        return
    end

    print("[AutoBuy] Purchasing ammo for " .. config.toolName)

    pcall(function()
        local Character = LocalPlayer.Character
        if not Character then return end

        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChild("Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then return end

        local ammoShop = FindShopItem(config.ammoShopNamePartial)
        if not ammoShop then
            print("[AutoBuy] Ammo shop not found for: " .. config.toolName)
            return
        end

        local ClickDetector = ammoShop:FindFirstChild("ClickDetector")
        if not ClickDetector then return end

        local ammoHead = ammoShop:FindFirstChild("Head")
        if not ammoHead then return end

        UnequipTools()
        task.wait(0.05)

        local previousAmmo = getAmmoCount(config.toolName) or 0
        local purchaseCount = 0
        local maxPurchases = 10 
        local attempts = 0
        local maxAttempts = 50
        
        local delayKey = "Ammo"

        while purchaseCount < maxPurchases and attempts < maxAttempts and ScriptRunning do
            Character = LocalPlayer.Character
            if not Character then break end

            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            Humanoid = Character:FindFirstChild("Humanoid")
            if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then break end

            local currentDelay = getgenv().AdaptiveDelays[delayKey]

            -- 1. Teleport to Head
            HumanoidRootPart.CFrame = CFrame.new(ammoHead.CFrame.Position + Vector3.new(0, 3, 0))
            HumanoidRootPart.Velocity = Vector3.zero
            task.wait(currentDelay) -- Adaptive Wait

            -- 2. Fire
            pcall(function() fireclickdetector(ClickDetector) end)

            -- 3. Void
            HumanoidRootPart.CFrame = CFrame.new(0, -10000000, 0)
            HumanoidRootPart.Velocity = Vector3.zero
            task.wait(0.2)

            local currentAmmo = getAmmoCount(config.toolName) or 0
            if currentAmmo > previousAmmo then
                previousAmmo = currentAmmo
                purchaseCount = purchaseCount + 1
                 -- Decrease delay on success
                getgenv().AdaptiveDelays[delayKey] = math.max(0.05, currentDelay - 0.05)
            else
                -- Increase delay on fail
                getgenv().AdaptiveDelays[delayKey] = currentDelay + 0.1
            end

            attempts = attempts + 1
        end

        local finalAmmo = getAmmoCount(config.toolName) or 0
        print("[AutoBuy] Ammo purchase complete. Total ammo: " .. finalAmmo)
    end)

    task.wait(0.1)
    AutoBuy.isBuying = false
    isBuying = false
    
    ResumeCombatAfterBuy()
end

-- NEW: Auto Armor Logic with Adaptive Delay
local function buyArmor()
    if AutoBuy.isBuying or not ScriptRunning then return end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    PauseCombatForBuy()
    AutoBuy.isBuying = true
    isBuying = true
    
    print("[AutoBuy] Armor level low. Purchasing Armor...")

    local success = pcall(function()
        if not workspace:FindFirstChild("Ignored") or not workspace.Ignored:FindFirstChild("Shop") then return end
        local armorShop = workspace.Ignored.Shop["[High-Medium Armor] - $2513"]
        if not armorShop then
             print("[AutoBuy] Armor shop not found.")
             return 
        end
        local cd = armorShop:FindFirstChild("ClickDetector")
        local head = armorShop:FindFirstChild("Head")
        if not cd or not head then return end
        
        UnequipTools()

        -- Repeat until armor filled (>30)
        local armorVal = nil
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BodyEffects") then
            armorVal = LocalPlayer.Character.BodyEffects:FindFirstChild("Armor")
        end
        if not armorVal then return end

        local maxTries = 20
        local tries = 0
        local delayKey = "Armor"
        
        while armorVal.Value < 30 and tries < maxTries and ScriptRunning do
             local char = LocalPlayer.Character
             if not char or not char:FindFirstChild("HumanoidRootPart") then break end
             
             local currentDelay = getgenv().AdaptiveDelays[delayKey]
             
             -- Teleport
             char.HumanoidRootPart.CFrame = head.CFrame * CFrame.new(0, 3, 0)
             char.HumanoidRootPart.Velocity = Vector3.zero
             task.wait(currentDelay) -- Adaptive Wait
             
             -- Click
             pcall(function() fireclickdetector(cd) end)
             
             -- Void
             char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
             task.wait(0.3)
             
             -- Check if armor increased (We need to wait a frame for it to update usually, but loop handles it)
             -- Since we can't easily check 'success' of click without waiting, we'll optimistically adjust or base on value change
             if armorVal.Value > 30 then
                 -- Success
                 getgenv().AdaptiveDelays[delayKey] = math.max(0.05, currentDelay - 0.05)
             else
                 -- Assume fail/lag if loop continues
                 getgenv().AdaptiveDelays[delayKey] = currentDelay + 0.1
             end
             
             tries = tries + 1
        end
    end)

    if not success then print("[AutoBuy] Error buying armor") end
    
    AutoBuy.isBuying = false
    isBuying = false
    ResumeCombatAfterBuy()
end

-- NEW: Fire Armor Buy Function
local function buyFireArmor()
    if not getgenv().FireArmorautobuy or AutoBuy.isBuying or not ScriptRunning then return end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    PauseCombatForBuy()
    AutoBuy.isBuying = true
    isBuying = true

    print("[AutoBuy] Fire Armor level low. Purchasing Fire Armor...")

    local success = pcall(function()
        if not workspace:FindFirstChild("Ignored") or not workspace.Ignored:FindFirstChild("Shop") then return end
        -- Explicit path requested
        local fireArmorShop = workspace.Ignored.Shop:FindFirstChild("[Fire Armor] - $2623")
        if not fireArmorShop then
             print("[AutoBuy] Fire Armor shop not found.")
             return
        end
        local cd = fireArmorShop:FindFirstChild("ClickDetector")
        local head = fireArmorShop:FindFirstChild("Head")
        if not cd or not head then return end

        UnequipTools()

        -- Repeat until fire armor filled (>50)
        local fArmorVal = nil
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BodyEffects") then
            fArmorVal = LocalPlayer.Character.BodyEffects:FindFirstChild("FireArmor")
        end
        if not fArmorVal then return end

        local maxTries = 20
        local tries = 0
        local delayKey = "FireArmor"

        -- Init delay if missing
        if not getgenv().AdaptiveDelays[delayKey] then getgenv().AdaptiveDelays[delayKey] = 0.15 end

        while fArmorVal.Value < 50 and tries < maxTries and ScriptRunning and getgenv().FireArmorautobuy do
             local char = LocalPlayer.Character
             if not char or not char:FindFirstChild("HumanoidRootPart") then break end

             local currentDelay = getgenv().AdaptiveDelays[delayKey]

             -- Teleport
             char.HumanoidRootPart.CFrame = head.CFrame * CFrame.new(0, 3, 0)
             char.HumanoidRootPart.Velocity = Vector3.zero
             task.wait(currentDelay)

             -- Click
             pcall(function() fireclickdetector(cd) end)

             -- Void
             char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
             task.wait(0.3)

             tries = tries + 1
        end
    end)

    if not success then print("[AutoBuy] Error buying fire armor") end

    AutoBuy.isBuying = false
    isBuying = false
    ResumeCombatAfterBuy()
end

local function reloadWeapon(weaponName)
    pcall(function()
        local Character = LocalPlayer.Character
        if Character then
            for _, tool in ipairs(Character:GetChildren()) do
                if tool:IsA("Tool") and tool.Name == weaponName and tool:FindFirstChild("Ammo") then
                    local ammo = tool:FindFirstChild("Ammo")
                    if ammo and ammo.Value and ammo.Value == 0 then
                        local skip = false
                        if (isGrabMode or isStompMode) and CombatTarget and CombatTarget.Character and IsTargetKO(CombatTarget.Character) then
                             skip = true
                        end
                        
                        if not skip then
                            MainEvent:FireServer("Reload", tool)
                        end
                    end
                end
            end
        end
    end)
end

local function autoEquipWeapons()
    if isFlamethrowerStick or isFlamethrowerLoop then return end
    if AutoBuy.isEquipping then
        return
    end

    AutoBuy.isEquipping = true

    pcall(function()
        local Character = LocalPlayer.Character
        local Backpack = LocalPlayer:FindFirstChild("Backpack")

        if Character and Backpack then
            local rifle = Backpack:FindFirstChild(WeaponConfig.rifle.toolName)
            if rifle and not Character:FindFirstChild(WeaponConfig.rifle.toolName) then
                rifle.Parent = Character
            end

            task.wait(0.05)

            -- Replaced Flintlock with AUG
            local aug = Backpack:FindFirstChild(WeaponConfig.aug.toolName)
            if aug and not Character:FindFirstChild(WeaponConfig.aug.toolName) then
                aug.Parent = Character
            end
        end
    end)

    AutoBuy.isEquipping = false
end

task.spawn(function()
    while ScriptRunning do
        task.wait(0.5)
        if not ScriptRunning then break end
        pcall(function()
            local Character = LocalPlayer.Character
            if Character then
                for _, tool in ipairs(Character:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
                        local ammo = tool:FindFirstChild("Ammo")
                        if ammo and ammo.Value and ammo.Value == 0 then
                            local shouldSkipReload = false
                            if (isGrabMode or isStompMode) and CombatTarget and CombatTarget.Character and IsTargetKO(CombatTarget.Character) then
                                shouldSkipReload = true
                            end

                            if not shouldSkipReload then
                                MainEvent:FireServer("Reload", tool)
                            end
                        end
                    end
                end
            end
        end)
    end
end)

task.spawn(function()
    print("[AutoBuy] Auto-buy system started")

    while ScriptRunning do
        task.wait(1)
        if not ScriptRunning then break end

        pcall(function()
            if not AutoBuy.isBuying and not isBuying and not isBuyingGun and not IsTeleporting and not isSavingOwner and not isUndergroundAttack and not isFlinging and not isAutoFling and not isSyncStomp and not isSyncLoop and not isFlamethrowerStick and not isFlamethrowerLoop then
                
                -- Check Fire Armor (Prioritized if enabled)
                if getgenv().FireArmorautobuy then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BodyEffects") and LocalPlayer.Character.BodyEffects:FindFirstChild("FireArmor") then
                        if LocalPlayer.Character.BodyEffects.FireArmor.Value < 50 then
                            buyFireArmor()
                        end
                    end
                end
                
                -- Check Armor
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BodyEffects") and LocalPlayer.Character.BodyEffects:FindFirstChild("Armor") then
                    if LocalPlayer.Character.BodyEffects.Armor.Value < 30 then
                        buyArmor()
                    end
                end
                
                -- Check Guns
                if not hasGun(WeaponConfig.rifle.toolName) then
                    print("[AutoBuy] Rifle not found, purchasing...")
                    buyWeapon("rifle")
                    task.wait(0.2)
                else
                    local rifleAmmo = getAmmoCount(WeaponConfig.rifle.toolName)
                    if rifleAmmo and rifleAmmo == 0 then
                        print("[AutoBuy] Rifle ammo depleted, purchasing...")
                        buyAmmo("rifle")
                        task.wait(0.2)
                        reloadWeapon(WeaponConfig.rifle.toolName)
                    end
                end

                task.wait(0.2)

                -- Replaced Flintlock Logic with AUG
                if not hasGun(WeaponConfig.aug.toolName) then
                    print("[AutoBuy] AUG not found, purchasing...")
                    buyWeapon("aug")
                    task.wait(0.2)
                else
                    local augAmmo = getAmmoCount(WeaponConfig.aug.toolName)
                    if augAmmo and augAmmo == 0 then
                        print("[AutoBuy] AUG ammo depleted, purchasing...")
                        buyAmmo("aug")
                        task.wait(0.2)
                        reloadWeapon(WeaponConfig.aug.toolName)
                    end
                end

                task.wait(0.2)
                if hasGun(WeaponConfig.rifle.toolName) and hasGun(WeaponConfig.aug.toolName) then
                    autoEquipWeapons()
                end
            end
        end)
    end
end)

-- ==================== SHOOTING SYSTEM ====================

RunService.Heartbeat:Connect(function()
    -- FIX: Logic adapted from Forsh for better reliability
    pcall(function()
        if not CombatTarget or not CombatTarget.Character or not CombatTarget.Character:FindFirstChild("HumanoidRootPart") 
           or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChildOfClass("Tool") 
           or not LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle") 
           or not isShooting then
            return
        elseif CombatTarget == LocalPlayer then
            isShooting = false
            return
        else
            local targetHead = CombatTarget.Character:FindFirstChild("Head")
            local be = CombatTarget.Character:FindFirstChild("BodyEffects")
            
            local isKO = be and be:FindFirstChild("K.O") and be["K.O"].Value
            local isGrabbed = CombatTarget.Character:FindFirstChild("GRABBING_CONSTRAINT")
            local hrp = CombatTarget.Character:FindFirstChild("HumanoidRootPart")
            local hasFF = CombatTarget.Character:FindFirstChildOfClass("ForceField")

            -- Forsh style checks: If KO, Grabbed, No HRP, No Head, or ForceField -> Don't shoot
            if isKO or isGrabbed or not hrp or not targetHead or hasFF then
                return
            else
                local myChar = LocalPlayer.Character
                for _, tool in ipairs(myChar:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
                        local handle = tool.Handle
                        MainEvent:FireServer("ShootGun", handle, handle.Position, targetHead.Position, targetHead, Vector3.new(0, 0, 0))
                    end
                end
            end
        end
    end)
end)

-- ==================== COMBAT HELPERS ====================

local function ActivateKnockMode(targetPlayer)
    if not targetPlayer then return end
    if targetPlayer == LocalPlayer then print("Cannot target self.") return end -- Self-target check

    print("[Combat] Activating KNOCK mode on " .. targetPlayer.Name)
    ToggleWallet(false) 
    
    isGrabMode = false
    isStompMode = false
    isLoopMode = false
    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false
    AutoFlingTarget = nil
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false
    
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end

    CombatTarget = targetPlayer
    isShooting = true
    isIdle = false
    isKnockMode = true
end

ActivateStompMode = function(targetPlayer)
    if not targetPlayer then return end
    if targetPlayer == LocalPlayer then print("Cannot target self.") return end
    print("[Combat] Activating STOMP mode on " .. targetPlayer.Name)
    
    ToggleWallet(false)
    
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    
    isKnockMode = false; isGrabMode = false; isLoopMode = false; isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; AutoFlingTarget = nil; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

    reloadTool()
    CombatTarget = targetPlayer
    isShooting = true
    isIdle = false
    isStompMode = true 
end

local function ActivateBringMode(targetPlayer)
    if not targetPlayer then return end
    if targetPlayer == LocalPlayer then print("Cannot target self.") return end
    print("[Combat] Activating BRING mode on " .. targetPlayer.Name)
    
    ToggleWallet(false)
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    isKnockMode = false; isStompMode = false; isLoopMode = false; isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; AutoFlingTarget = nil; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

    CombatTarget = targetPlayer
    isShooting = true
    isIdle = false
    isGrabMode = true
end

local function ActivateLoopMode(targetPlayer)
    if not targetPlayer then return end
    if targetPlayer == LocalPlayer then print("Cannot target self.") return end
    print("[Combat] Activating LOOP mode on " .. targetPlayer.Name)
    
    ToggleWallet(false)
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    isKnockMode = false; isGrabMode = false; isStompMode = false; isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; AutoFlingTarget = nil; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

    reloadTool()
    CombatTarget = targetPlayer
    isShooting = true
    isIdle = false
    isLoopMode = true
end

local function ActivateProtectionRetaliation(targetPlayer)
    if not targetPlayer then return end
    print("[Protection] Retaliating against " .. targetPlayer.Name .. " (Stomp Mode)")
    ActivateStompMode(targetPlayer)
end

-- ==================== PROTECTION LOOP ====================

task.spawn(function()
    while ScriptRunning do
        task.wait(0.1)

        if AutoBuy.isBuying or isBuying or isBuyingGun then
            -- do nothing
        else
            local playersToMonitor = {}
            
            for protectedName, _ in pairs(getgenv().sentryprotected) do
                local protectedPlayer = Players:FindFirstChild(protectedName)
                if protectedPlayer then playersToMonitor[protectedName] = protectedPlayer end
            end

            for name, player in pairs(playersToMonitor) do
                 if player and player.Character then
                    local char = player.Character
                    local humanoid = char:FindFirstChild("Humanoid")
                    local bodyEffects = char:FindFirstChild("BodyEffects")
                    local lastDamager = bodyEffects and bodyEffects:FindFirstChild("LastDamager")

                    if humanoid and lastDamager then
                        local currentHealth = humanoid.Health

                        if getgenv().lastHealths[name] == nil then
                            getgenv().lastHealths[name] = currentHealth
                        end

                        if currentHealth < getgenv().lastHealths[name] then
                            getgenv().lastHealths[name] = currentHealth
                            
                            local attackerName = tostring(lastDamager.Value)
                            if attackerName ~= "" and attackerName ~= LocalPlayer.Name then
                                local attacker = Players:FindFirstChild(attackerName)
                                if attacker then
                                    if CombatTarget ~= attacker then
                                        -- WHITELIST CHECK
                                        if not getgenv().whitelisted[attackerName] then
                                            print("[Protection] " .. name .. " attacked by " .. attackerName .. " - ACTIVATING S! RETALIATION!")
                                            ActivateProtectionRetaliation(attacker)
                                        else
                                            print("[Protection] Ignored attack from whitelisted user: " .. attackerName)
                                        end
                                    end
                                end
                            end
                        else
                            getgenv().lastHealths[name] = currentHealth
                        end
                    end
                 end
            end
        end
    end
end)

-- ==================== AUTO BLOCK (User Added) ====================
task.spawn(function()
    RunService.Heartbeat:Connect(function()
        if getgenv().AutoBlock then
            -- DISABLE IF FS IS ACTIVE
            if not isFlamethrowerStick and not isFlamethrowerLoop then
                MainEvent:FireServer("Block", true)
                task.wait()
                MainEvent:FireServer("Block", false)
            end
        end
    end)
end)

-- ==================== AUTO SAVE OWNER (as!) REWRITE ====================

local function handleAutoSave(enable)
    AutoSaveEnabled = enable
    if enable then
        print("[AutoSave] Active - G-Bring Logic (Retry Enhanced).")
        task.spawn(function()
            local SafeZonePos = Vector3.new(300.090576171875, 106.78191375732422, -616.1978759765625)
            local RunService = game:GetService("RunService")

            while AutoSaveEnabled and ScriptRunning do
                task.wait(0.1)
                
                local owner = Stand.OwnerPlayer or Stand:FindOwner()
                
                -- Check Owner Status
                if owner and owner.Character and IsTargetKO(owner.Character) and not isSavingOwner then
                    local ownerTorso = owner.Character:FindFirstChild("UpperTorso") or owner.Character:FindFirstChild("Torso")
                    
                    -- DISTANCE CHECK (> 50 studs)
                    if ownerTorso and (ownerTorso.Position - SafeZonePos).Magnitude > 50 then
                        
                        isSavingOwner = true
                        print("[AutoSave] Engaging Rescue Operation...")
                        
                        -- DISABLE OTHER MODES
                        ToggleWallet(false)
                        Stand.IsActive = false
                        if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
                        if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
                        isKnockMode = false; isGrabMode = false; isStompMode = false; isFlinging = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

                        local success = pcall(function()
                            local myChar = LocalPlayer.Character
                            local myHRP = myChar:FindFirstChild("HumanoidRootPart")
                            local targetChar = owner.Character
                            local targetTorso = targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Torso")
                            
                            if not myHRP or not targetTorso then return end

                            -- Ensure Combat Tool is equipped (Crucial for Grabbing)
                            local combat = LocalPlayer.Backpack:FindFirstChild("Combat")
                            if combat then 
                                LocalPlayer.Character.Humanoid:EquipTool(combat) 
                            end

                            -- PHASE 1: FORCE GRAB (The Fix)
                            -- We loop here until the server confirms they are grabbed
                            local grabAttempts = 0
                            local isGrabbed = false
                            
                            repeat
                                if not AutoSaveEnabled or not IsTargetKO(targetChar) then break end
                                
                                targetTorso = targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Torso")
                                isGrabbed = targetChar:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                                if not isGrabbed then
                                    -- Teleport logic from your reference (Direct Overlap)
                                    myHRP.Velocity = Vector3.zero
                                    myHRP.CFrame = targetTorso.CFrame -- Direct overlap
                                    
                                    -- Fire Event
                                    MainEvent:FireServer("Grabbing", false)
                                    
                                    -- Short wait to allow server to register
                                    task.wait(0.15) 
                                end
                                grabAttempts = grabAttempts + 1
                            until isGrabbed or grabAttempts > 20 -- Give up after 20 tries to prevent infinite freeze

                            -- PHASE 2: TRANSPORT (Only if grab succeeded)
                            if isGrabbed then
                                print("[AutoSave] Grab confirmed. Transporting.")
                                
                                -- Teleport logic from your reference (Loop 5 times)
                                for i = 1, 10 do -- Increased to 10 for safety
                                    if myHRP then
                                        myHRP.CFrame = CFrame.new(SafeZonePos)
                                        myHRP.Velocity = Vector3.zero 
                                    end
                                    RunService.Heartbeat:Wait()
                                end

                                -- Release
                                MainEvent:FireServer("Grabbing", false)
                                task.wait(0.3)
                                
                                -- PHASE 3: VOID RELOAD (From reference)
                                if myChar:FindFirstChild("HumanoidRootPart") then
                                    myChar.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
                                    myChar.HumanoidRootPart.Velocity = Vector3.zero
                                end
                                
                                task.wait(0.2)
                                if reloadTool then reloadTool() end
                                task.wait(0.5)
                            end
                        end)
                        
                        if not success then warn("[AutoSave] Error during rescue.") end

                        -- Reset
                        isSavingOwner = false
                        Stand:Fade()
                    end
                end
            end
        end)
    else
        print("[AutoSave] Disabled")
        isSavingOwner = false
    end
end

-- ==================== COMBAT POSITIONING SYSTEMS (UPDATED WITH SPIRAL & OFFSETS) ====================

task.spawn(function()
    while ScriptRunning do
        if BaitConfig.Enabled and CombatTarget and not isBuying and not isSavingOwner and not IsTeleporting and not isFlinging and not isAutoFling and not isFlamethrowerStick and not isFlamethrowerLoop then
            local tChar = CombatTarget.Character
            if tChar and not IsTargetKO(tChar) and not IsTargetDead(tChar) and not HasForceField(tChar) then
                if os.clock() - BaitConfig.LastBait >= BaitConfig.Interval then
                    BaitRunning = true
                    
                    pcall(function()
                        local char = LocalPlayer.Character
                        if char and char:FindFirstChild("HumanoidRootPart") then
                            local hrp = char.HumanoidRootPart
                            local oldCF = hrp.CFrame
                            
                            hrp.AssemblyLinearVelocity = Vector3.zero
                            hrp.AssemblyAngularVelocity = Vector3.zero

                            hrp.CFrame = oldCF + Vector3.new(0, BaitConfig.UpDistance, 0)
                            task.wait(BaitConfig.HoldTime)
                        end
                    end)

                    BaitRunning = false
                    BaitConfig.LastBait = os.clock()
                end
            else
                BaitRunning = false
            end
        else
            BaitRunning = false
        end
        task.wait(0.1)
    end
end)

RunService.Stepped:Connect(function()
    -- Only run if active combat mode and valid states
    if (isKnockMode or isStompMode or isLoopMode or isGrabMode) and CombatTarget and not isBuying and not isBuyingGun and not AutoBuy.isBuying and not IsTeleporting and not isSavingOwner and not isFlinging and not isAutoFling and not isSyncStomp and not isSyncLoop and not isFlamethrowerStick and not isFlamethrowerLoop then
        if BaitRunning then return end

        pcall(function()
            if not CombatTarget.Character then return end
            if not LocalPlayer.Character then return end

            local targetChar = CombatTarget.Character
            local myChar = LocalPlayer.Character
            
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local myHRP = myChar:FindFirstChild("HumanoidRootPart")
            if not targetHRP or not myHRP then return end
            
            if HasForceField(targetChar) then return end
            if IsTargetDead(targetChar) then return end
            
            -- If Grab Mode is active, let the Grab Loop handle positioning
            if isGrabMode then return end
            
            -- If Target is KO, let Stomp/Knock loops handle positioning
            if (isKnockMode or isStompMode or isLoopMode) and IsTargetKO(targetChar) then
                return
            end

            -- // ===== [ TOGGLE LOGIC: ADVANCED VS INSTANT ] ===== //
            local finalPos, finalRot
            
            if getgenv().UseAdvancedCombat then
                -- [ SLOW/SAFE ] SPIRAL & DESYNC LOGIC
                local combatSettings = getgenv().CombatSettings
                local offsetSettings = combatSettings.Offsets.Detailed
                local spiralSettings = combatSettings.Spiral
                
                -- Spiral Math
                local t = os.clock()
                local angle = t * spiralSettings.Speed
                local spiralX = math.cos(angle) * spiralSettings.Distance
                local spiralZ = math.sin(angle) * spiralSettings.Distance
                
                -- Random Offsets
                local randX = math.random(offsetSettings.X_Max, offsetSettings.X_Min)
                local randY = math.random(offsetSettings.Y_Max, offsetSettings.Y_Min)
                local randZ = math.random(offsetSettings.Z_Max, offsetSettings.Z_Min)
                
                local combinedOffset = Vector3.new(spiralX + randX, randY, spiralZ + randZ)

                -- Prediction using Resolver
                local predPos = GetResolverPrediction(targetHRP)
                finalPos = predPos + combinedOffset

                -- 360 Rotation
                local rotX = math.rad(math.random(0, offsetSettings.Rotation))
                local rotY = math.rad(math.random(0, offsetSettings.Rotation))
                local rotZ = math.rad(math.random(0, offsetSettings.Rotation))
                finalRot = CFrame.Angles(rotX, rotY, rotZ)
            else
                -- [ INSTANT/KILL ] DIRECT LOCK LOGIC
                -- No spiral, no massive offsets, just slight elevation behind target for clean shots
                local directPos = targetHRP.Position + (targetHRP.Velocity * 0.05) -- Minimal prediction
                finalPos = directPos + Vector3.new(0, 4, 2) -- Standard overhead position
                finalRot = CFrame.lookAt(finalPos, targetHRP.Position) -- Look directly at them
            end

            -- Safety Check for NaN
            if finalPos.X ~= finalPos.X then return end

            myHRP.CFrame = CFrame.new(finalPos) * (finalRot or CFrame.new())
            myHRP.Velocity = Vector3.zero
            myHRP.RotVelocity = Vector3.zero
        end)
    end
end)

-- .gknock - Stomp logic (The Finisher) & K! Mode Logic
task.spawn(function()
    while ScriptRunning do
        RunService.Heartbeat:Wait() -- FAST LOOP
        if (isKnockMode or isStompMode) and CombatTarget and not isBuying and not isSavingOwner then
            pcall(function()
                local targetChar = CombatTarget.Character
                local myChar = LocalPlayer.Character
                
                if not targetChar or not myChar then
                    task.wait(1)
                    if not CombatTarget or not CombatTarget.Character then Stand:Fade() end
                    return
                end

                if HasForceField(targetChar) then
                    isShooting = false
                    return
                end
                
                local myHRP = myChar:FindFirstChild("HumanoidRootPart")
                if not myHRP then return end
                
                local isKO = IsTargetKO(targetChar)
                local isDead = IsTargetDead(targetChar)

                if isDead then
                    print("[Combat] Target eliminated/Dead")
                    if myHRP then
                        -- ** VOID SPAM LOGIC (OUT VOID 0.11s) **
                        myHRP.CFrame = CFrame.new(0, 10000000, 0)
                        myHRP.Velocity = Vector3.zero
                    end
                    task.wait(getgenv().CombatSettings.VoidSpam.OutVoid) -- 0.11s
                    Stand:Fade()
                    return
                end

                if isKO then
                    BaitRunning = false
                    
                    -- FORCE STAND UP (Modified Request)
                    pcall(function()
                         LocalPlayer.Character.Humanoid.Sit = false
                         LocalPlayer.Character.Humanoid.Jump = true
                    end)

                    if isKnockMode then
                        isShooting = false
                        print("[Knock] Target KO'd. Task Complete. Fading.")
                        
                        -- ADV TALK LOGIC
                        if getgenv().AdvText then
                             local msg = AdvMessages[math.random(1, #AdvMessages)]
                             SendChatMessage(msg)
                             task.wait(0.1)
                        end
                        
                        isKnockMode = false
                        Stand:Fade()
                        task.delay(0.5, function() Stand:Fade() end)
                        return
                    end

                    if isStompMode then
                        isShooting = false
                        isIdle = false

                        local targetUpperTorso = targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Torso")

                        if targetUpperTorso then
                            print("[Stomp] Target KO'd. Executing Stomp...")

                            local stompStart = os.clock()
                            local stompTimeout = 4 
                            local stompSuccess = false
                            
                            while (os.clock() - stompStart < stompTimeout) do
                                if not targetChar or not targetChar.Parent or IsTargetDead(targetChar) then
                                    stompSuccess = true
                                    break
                                end

                                if myHRP and targetUpperTorso then
                                    myHRP.Velocity = Vector3.zero
                                    myHRP.RotVelocity = Vector3.zero
                                    
                                    -- [ UPDATED: FIXED PREDICTION & OFFSET ] --
                                    -- Offset is 2.6 studs above UpperTorso
                                    local sHeight = 2.6
                                    local sOffset = Vector3.new(0, sHeight, 0) 
                                    
                                    -- Use Resolver Prediction
                                    local predPos = GetPredictedPosition(targetUpperTorso, PREDICTION_TIME)
                                    if predPos.X == predPos.X then
                                         myHRP.CFrame = CFrame.new(predPos + sOffset)
                                    end
                                end

                                MainEvent:FireServer("Stomp")
                                RunService.Heartbeat:Wait()
                            end
                            
                            -- ADV TALK LOGIC for STOMP
                            if getgenv().AdvText and (stompSuccess or IsTargetDead(targetChar)) then
                                local msg = AdvMessages[math.random(1, #AdvMessages)]
                                SendChatMessage(msg)
                                task.wait(0.1)
                            end

                            if stompSuccess or IsTargetDead(targetChar) then
                                print("[Stomp] Target confirmed DEAD. Retracting to Void.")
                            else
                                print("[Stomp] Stomp timed out (Lag/Glitch). Retracting.")
                            end

                            pcall(function()
                                if myHRP then
                                    -- ** VOID SPAM LOGIC IN (0.42s) **
                                    myHRP.CFrame = CFrame.new(0, 10000000, 0)
                                    myHRP.Velocity = Vector3.zero
                                end
                                task.wait(getgenv().CombatSettings.VoidSpam.InVoid) -- 0.42s
                                reloadTool()
                                task.wait(0.1)
                            end)

                            isStompMode = false
                            Stand:Fade()
                            task.delay(1, function() Stand:Fade() end)
                        end
                    end

                elseif not isKO and not isDead then
                    isShooting = true
                    isIdle = false
                end
            end)
        end
    end
end)


-- .gbring - Grab logic (FIXED: Go to Void after drop)
task.spawn(function()
    while ScriptRunning do
        task.wait()
        if isGrabMode and CombatTarget and not isBuying and not isSavingOwner then
            pcall(function()
                local targetChar = CombatTarget.Character
                local myChar = LocalPlayer.Character

                if not targetChar or not myChar then
                    Stand:Fade()
                    return
                end

                local myHRP = myChar:FindFirstChild("HumanoidRootPart")

                if IsTargetDead(targetChar) then
                    print("[Combat] Target dead (Bring Mode)")
                    Stand:Fade()
                    return
                end

                local isKO = IsTargetKO(targetChar)
                local isGrabbed = targetChar:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                -- PHASE 1: KO Target (if necessary)
                if not isKO then
                    if HasForceField(targetChar) then
                        isShooting = false
                        return
                    end

                    isShooting = true
                    isIdle = false
                    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
                    if myHRP and targetHRP then
                        -- UPDATED: Fast Random Strafe (Non-Orbit)
                        local randomOffset = Vector3.new(math.random(-15, 15), math.random(2, 8), math.random(-15, 15))
                        myHRP.CFrame = CFrame.new(targetHRP.Position + randomOffset, targetHRP.Position)
                    end
                    return
                end

                isShooting = false

                -- PHASE 2: Grab attempt
                if isKO and not isGrabbed then
                    local targetUpperTorso = targetChar:FindFirstChild("UpperTorso")

                    if targetUpperTorso and myHRP then
                        myHRP.Velocity = Vector3.zero
                        -- UPDATED: Grab Prediction and Offset (2.6 above)
                        local predPos = GetPredictedPosition(targetUpperTorso, PREDICTION_TIME)
                        if predPos.X == predPos.X then
                             myHRP.CFrame = CFrame.new(predPos + Vector3.new(0, 2.6, 0))
                        end
                        
                        task.wait(0.2)
                        MainEvent:FireServer("Grabbing", false)
                        task.wait(0.5) 
                        isGrabbed = targetChar:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                    end
                end

                -- PHASE 3: Teleport and Drop
                if isGrabbed then
                    print("[Combat] Grab successful, teleporting to owner.")
                    local ReturnTarget = Stand.FollowTarget or Stand.OwnerPlayer or Stand:FindOwner()

                    if ReturnTarget and ReturnTarget.Character and myHRP then
                        local ReturnHRP = ReturnTarget.Character:FindFirstChild("HumanoidRootPart")
                        if ReturnHRP then
                            for i=1, 5 do
                                myHRP.CFrame = ReturnHRP.CFrame * CFrame.new(0, 0, 4)
                                task.wait(0.05)
                            end
                        end
                    end

                    -- Release target
                    MainEvent:FireServer("Grabbing", false)
                    task.wait(0.3)
                    
                    -- === NEW RELOAD IN VOID LOGIC (Post-Bring) ===
                    -- FIX: Ensure we are safely away before reloading to prevent glitches
                     pcall(function()
                        if myChar:FindFirstChild("HumanoidRootPart") then
                            myChar.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
                            myChar.HumanoidRootPart.Velocity = Vector3.zero
                        end
                        task.wait(0.2)
                        -- NOW we reload, safely in the void
                        reloadTool()
                        task.wait(0.5)
                    end)
                    -- =============================================

                    -- DONE: Go to Fade
                    isGrabMode = false
                    Stand:Fade()
                end
            end)
        end
    end
end)


-- .l - Loop stomp mode
task.spawn(function()
    while ScriptRunning do
        RunService.Heartbeat:Wait() -- FAST LOOP
        if isLoopMode and CombatTarget then
            pcall(function()
                local targetChar = CombatTarget.Character
                local myChar = LocalPlayer.Character
                local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")

                local shouldWaitInVoid = false

                if not targetChar or not targetChar.Parent then
                    shouldWaitInVoid = true
                elseif IsTargetDead(targetChar) then
                    shouldWaitInVoid = true
                elseif HasForceField(targetChar) then
                    shouldWaitInVoid = true
                end

                if shouldWaitInVoid then
                    isShooting = false
                    if myHRP then
                        myHRP.CFrame = CFrame.new(0, 10000000, 0)
                        myHRP.Velocity = Vector3.zero
                    end
                    task.wait(getgenv().CombatSettings.VoidSpam.OutVoid) -- 0.11s
                    return
                end

                if myChar and myHRP then
                    local isKO = IsTargetKO(targetChar)
                    
                    if isKO then
                        BaitRunning = false

                        isShooting = false
                        local targetUpperTorso = targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Torso")
                        
                        if targetUpperTorso then
                            myHRP.Velocity = Vector3.zero
                            
                            -- Stomp Settings
                            local sHeight = 2.6 -- UPDATED: 2.6
                            local sRand = getgenv().CombatSettings.Offsets.StompRandom -- 0s
                            local lOffset = Vector3.new(0, sHeight, 0)
                            
                            -- PREDICTION STOMP (RESOLVER)
                            local predPos = GetPredictedPosition(targetUpperTorso, PREDICTION_TIME)
                            if predPos.X == predPos.X then
                                 myHRP.CFrame = CFrame.new(predPos + lOffset)
                            end
                            
                            task.wait(0.1) 
                            MainEvent:FireServer("Stomp")
                            task.wait(0.3) 
                            
                            if myHRP then
                                myHRP.CFrame = CFrame.new(0, 10000000, 0)
                                myHRP.Velocity = Vector3.zero
                            end
                            
                            -- ** VOID SPAM IN (0.42s) **
                            task.wait(getgenv().CombatSettings.VoidSpam.InVoid)
                            for _, tool in ipairs(myChar:GetChildren()) do
                                if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
                                    MainEvent:FireServer("Reload", tool)
                                end
                            end
                        end
                    else
                        if BaitRunning then 
                            isShooting = true
                            return 
                        end
                        -- Positioning handled by Stepped loop
                        isShooting = true
                    end
                end
            end)
        end
    end
end)

-- ==================== RELOAD IN VOID PROTECTION ====================
task.spawn(function()
    RunService.Stepped:Connect(function()
        if not ScriptRunning then return end
        
        pcall(function()
            local char = LocalPlayer.Character
            if not char then return end
            
            local bodyEffects = char:FindFirstChild("BodyEffects")
            if not bodyEffects then return end
            
            local reloadVal = bodyEffects:FindFirstChild("Reload")
            if reloadVal and reloadVal.Value == true then
                
                local shouldVoid = true
                
                if isGrabMode then
                    shouldVoid = false
                end
                
                if (isStompMode or isLoopMode) and CombatTarget and CombatTarget.Character then
                    if IsTargetKO(CombatTarget.Character) then
                        shouldVoid = false 
                    end
                end
                
                if AutoBuy.isBuying or isBuying or isBuyingGun then
                    shouldVoid = false
                end

                if isFlamethrowerStick or isFlamethrowerLoop then
                    shouldVoid = false
                end
                
                if shouldVoid then
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = CFrame.new(
                            math.random(-90000000, 90000000), 
                            math.random(-90000000, 90000000), 
                            math.random(-90000000, 90000000)
                        )
                        hrp.Velocity = Vector3.zero
                    end
                end
            end
        end)
    end)
end)

-- ==================== FADE FUNCTION ====================

function Stand:Fade()
    if Stand.FollowConnection then
        pcall(function() Stand.FollowConnection:Disconnect() end)
        Stand.FollowConnection = nil
    end
    if Stand.TargetConnection then
        pcall(function() Stand.TargetConnection:Disconnect() end)
        Stand.TargetConnection = nil
    end
    if FlingConnection then
        pcall(function() FlingConnection:Disconnect() end)
        FlingConnection = nil
    end
    if FlamethrowerConnection then
        pcall(function() FlamethrowerConnection:Disconnect() end)
        FlamethrowerConnection = nil
    end

    Stand.IsActive = false
    Stand.IsTargeting = false
    Stand.TargetPlayer = nil

    CombatTarget = nil
    isShooting = false
    isIdle = true
    isKnockMode = false
    isGrabMode = false
    isStompMode = false
    isLoopMode = false
    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false
    AutoFlingTarget = nil
    BaitRunning = false
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false

    reloadTool()
    UnequipTools()

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    FadeConnection = RunService.Stepped:Connect(function()
        if not ScriptRunning then
            if FadeConnection then
                pcall(function() FadeConnection:Disconnect() end)
                FadeConnection = nil
            end
            return
        end

        if Stand.IsActive or isKnockMode or isGrabMode or isStompMode or isLoopMode or CombatTarget or isVoidSpam or IsTeleporting or isSavingOwner or isBuying or isBuyingGun or AutoBuy.isBuying or isUndergroundAttack or isFlinging or isAutoFling or isSyncStomp or isSyncLoop or isFlamethrowerStick or isFlamethrowerLoop then
            if FadeConnection then
                pcall(function() FadeConnection:Disconnect() end)
                FadeConnection = nil
                print("Combat/Activity: Fade stopped")
            end
            return
        end

        pcall(function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BodyEffects") and LocalPlayer.Character.BodyEffects:FindFirstChild("Reload") then
                 if LocalPlayer.Character.BodyEffects.Reload.Value == true then
                     return 
                 end
            end

            local hrp = Stand:GetStandParts()
            if hrp then
                hrp.CFrame = CFrame.new(
                    math.random(-100000, 100000),
                    math.random(-100000, 100000),
                    math.random(-100000, 100000)
                )
                hrp.Velocity = Vector3.zero
            end
        end)
    end)

    print("Stand: Faded - Random teleport active")
end

-- ==================== TARGET ORBITING ====================

function Stand:Target(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        print("Stand: Target not found")
        return
    end
    ToggleWallet(false) 

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    if Stand.FollowConnection then
        pcall(function() Stand.FollowConnection:Disconnect() end)
        Stand.FollowConnection = nil
    end
    if Stand.TargetConnection then
        pcall(function() Stand.TargetConnection:Disconnect() end)
        Stand.TargetConnection = nil
    end

    Stand.IsActive = true
    Stand.IsTargeting = true
    Stand.TargetPlayer = targetPlayer

    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false
    AutoFlingTarget = nil
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false

    local hrp, humanoid = Stand:GetStandParts()
    if not hrp or not humanoid then
        print("Stand: Cannot get stand parts")
        return
    end

    pcall(function()
        hrp.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
    end)

    print("Stand: Orbiting " .. targetPlayer.Name)

    Stand.TargetConnection = RunService.Stepped:Connect(function(dt)
        if not ScriptRunning then
            if Stand.TargetConnection then
                pcall(function() Stand.TargetConnection:Disconnect() end)
                Stand.TargetConnection = nil
            end
            return
        end

        pcall(function()
            local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not targetHRP then
                print("Stand: Target lost")
                Stand:Untarget()
                return
            end

            local currentHrp = Stand:GetStandParts()
            if currentHrp then
                local randomOffset = Vector3.new(math.random(-30, 30), math.random(2, 8), math.random(-30, 30))
                -- Use Resolver prediction here
                local predPos = GetResolverPrediction(targetHRP)
                if predPos.X == predPos.X then
                    currentHrp.CFrame = CFrame.new(predPos + randomOffset, predPos)
                end
                currentHrp.Velocity = Vector3.zero
                currentHrp.RotVelocity = Vector3.zero
            end
        end)
    end)
end

function Stand:Untarget()
    if Stand.TargetConnection then
        pcall(function() Stand.TargetConnection:Disconnect() end)
        Stand.TargetConnection = nil
    end
    Stand.IsTargeting = false
    Stand.TargetPlayer = nil

    CombatTarget = nil
    isShooting = false
    isIdle = true

    print("Stand: Untargeted")
    Stand:Call()
end

-- ==================== OWNER FOLLOWING ====================

function Stand:Call()
    if isKnockMode or isGrabMode or isStompMode or isLoopMode or CombatTarget or isVoidSpam or IsTeleporting or isSavingOwner or isUndergroundAttack or isFlinging or isAutoFling or isSyncStomp or isSyncLoop or isFlamethrowerStick or isFlamethrowerLoop then
        if isKnockMode or isGrabMode or isStompMode or isUndergroundAttack or isFlinging or isAutoFling or isSyncStomp or isSyncLoop or isFlamethrowerStick or isFlamethrowerLoop then
            print("Stand: Switching from combat to follow...")
            isKnockMode = false; isGrabMode = false; isStompMode = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; AutoFlingTarget = nil; CombatTarget = nil; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false
        else
            return
        end
    end
    ToggleWallet(false) 

    if isBuying or isBuyingGun or AutoBuy.isBuying then
        return
    end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end

    if Stand.TargetConnection then
        pcall(function() Stand.TargetConnection:Disconnect() end)
        Stand.TargetConnection = nil
    end
    Stand.IsTargeting = false

    local Target = Stand.FollowTarget or Stand.OwnerPlayer or Stand:FindOwner()

    if not Target or not Target.Character then
        return
    end

    local TargetHRP = Target.Character:FindFirstChild("HumanoidRootPart")
    if not TargetHRP then
        return
    end

    local hrp, humanoid = Stand:GetStandParts()
    if not hrp or not humanoid then
        return
    end

    Stand.IsActive = true

    pcall(function()
        hrp.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Seated)
        hrp.CFrame = TargetHRP.CFrame * CFrame.new(Stand.Offset)
        hrp.Velocity = Vector3.zero
        hrp.RotVelocity = Vector3.zero
    end)

    print("Stand: Following " .. Target.Name)

    if Stand.FollowConnection then
        pcall(function() Stand.FollowConnection:Disconnect() end)
        Stand.FollowConnection = nil
    end

    Stand.FollowConnection = RunService.Stepped:Connect(function()
        if not ScriptRunning then
            if Stand.FollowConnection then
                pcall(function() Stand.FollowConnection:Disconnect() end)
                Stand.FollowConnection = nil
            end
            return
        end

        if isKnockMode or isGrabMode or isStompMode or isLoopMode or CombatTarget or isVoidSpam or IsTeleporting or isSavingOwner or isUndergroundAttack or isFlinging or isAutoFling or isSyncStomp or isSyncLoop or isFlamethrowerStick or isFlamethrowerLoop then
            if Stand.FollowConnection then
                pcall(function() Stand.FollowConnection:Disconnect() end)
                Stand.FollowConnection = nil
            end
            Stand.IsActive = false
            return
        end

        if isBuying or isBuyingGun or AutoBuy.isBuying then
            if Stand.FollowConnection then
                pcall(function() Stand.FollowConnection:Disconnect() end)
                Stand.FollowConnection = nil
            end
            Stand.IsActive = false
            return
        end

        pcall(function()
            local currentHrp = Stand:GetStandParts()
            if not currentHrp then return end

            local followTarget = Stand.FollowTarget or Stand.OwnerPlayer
            if not followTarget or not followTarget.Character then return end

            local targetHRP = followTarget.Character:FindFirstChild("HumanoidRootPart")
            if not targetHRP then return end

            if Stand.IsActive and not Stand.IsTargeting then
                local targetCFrame = targetHRP.CFrame * CFrame.new(Stand.Offset)
                currentHrp.CFrame = targetCFrame
                currentHrp.Velocity = Vector3.zero
                currentHrp.RotVelocity = Vector3.zero

                if currentHrp.Anchored then
                    currentHrp.Anchored = false
                end
            end
        end)
    end)
end

-- ==================== VOID SPAM SYSTEM ====================

local function handleVoidDrop()
    print("[Void] Dropping to void...")
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if Stand.TargetConnection then pcall(function() Stand.TargetConnection:Disconnect() end) Stand.TargetConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    
    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false
    AutoFlingTarget = nil
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false
    ToggleWallet(false)

    pcall(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
        end
    end)
end

local function handleVoidSpam(enable)
    if enable then
        if isVoidSpam then return end
        print("[Void] Void Spam Enabled")
        ToggleWallet(false)

        Stand.IsActive = false
        if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
        if Stand.TargetConnection then pcall(function() Stand.TargetConnection:Disconnect() end) Stand.TargetConnection = nil end
        if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
        if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
        if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end

        isVoidSpam = true
        IsTeleporting = false
        isSavingOwner = false
        isUndergroundAttack = false
        isFlinging = false
        isAutoFling = false
        AutoFlingTarget = nil
        isSyncStomp = false
        isSyncLoop = false
        isFlamethrowerStick = false
        isFlamethrowerLoop = false

        task.spawn(function()
            while isVoidSpam and ScriptRunning do
                pcall(function()
                    local char = LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
                    end
                end)
                task.wait(0.3)

                if not isVoidSpam then break end

                pcall(function()
                    local ReturnTarget = Stand.FollowTarget or Stand.OwnerPlayer or Stand:FindOwner()
                    local char = LocalPlayer.Character

                    if ReturnTarget and ReturnTarget.Character and ReturnTarget.Character:FindFirstChild("HumanoidRootPart") and char and char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.CFrame = ReturnTarget.Character.HumanoidRootPart.CFrame * CFrame.new(Stand.Offset)
                    end
                end)
                task.wait(0.05)
            end

            if not isVoidSpam and ScriptRunning then
                 handleVoidDrop()
            end
        end)
    else
        print("[Void] Void Spam Disabled - Returning to Void")
        isVoidSpam = false
        task.wait(0.1)
        handleVoidDrop()
    end
end

-- ==================== TELEPORT COMMAND (tp!) (UPDATED: EXISTING BIKE CHECK) ====================

local TpLocations = {
    bank = {
        hold = Vector3.new(-443.60626220703125, 38.99485397338867, -284.7694396972656),
        drop = Vector3.new(-881.9063720703125, 115.99784851074219, -857.9408569335938)
    },
    rev = {
        drop = Vector3.new(-640.8284, 47.4991, -105.9045),
        hold = Vector3.new(-640.8284, 347.4991, -105.9045)
    },
    roof1 = {
        drop = Vector3.new(-326.8387, 80.4318, -299.7459),
        hold = Vector3.new(-326.8387, 380.4318, -299.7459)
    },
    roof2 = {
        drop = Vector3.new(-438.6041, 80.4760, -224.9503),
        hold = Vector3.new(-438.6041, 380.4760, -224.9503) 
    },
    uphill = {
        drop = Vector3.new(435.8857, 106.6817, -624.2000),
        hold = Vector3.new(435.8857, 406.6817, -624.2000) 
    },
    flintlock = {
        drop = Vector3.new(-173.1670, 53.8086, -108.6511),
        hold = Vector3.new(-173.1670, 353.8086, -108.6511) 
    },
    mil = {
        drop = Vector3.new(-40.4651, 65.7530, -926.8167),
        hold = Vector3.new(-40.4651, 365.7530, -926.8167) 
    },
    db = {
        drop = Vector3.new(-1043.1888, 80.4086, -248.3395),
        hold = Vector3.new(-1043.1888, 380.4086, -248.3395) 
    },
    -- New locations added as requested
    lmg = {
        drop = Vector3.new(-618, 23, -295),
        hold = Vector3.new(-618, 323, -295)
    },
    downhill = {
        drop = Vector3.new(-583, 67, -688),
        hold = Vector3.new(-583, 367, -688)
    },
    food1 = {
        drop = Vector3.new(-284, 37, -820),
        hold = Vector3.new(-284, 337, -820)
    },
    food2 = {
        drop = Vector3.new(-331, 23, -295),
        hold = Vector3.new(-331, 323, -295)
    },
    rifle = {
        drop = Vector3.new(-267, 52, -220),
        hold = Vector3.new(-267, 352, -220)
    },
    bigarea = {
        drop = Vector3.new(13, 11, 207),
        hold = Vector3.new(13, 311, 207)
    },
    rpg = {
        drop = Vector3.new(111, -27, -273),
        hold = Vector3.new(111, 273, -273)
    }
}

local function handleTpCommand(arg1, arg2)
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if Stand.TargetConnection then pcall(function() Stand.TargetConnection:Disconnect() end) Stand.TargetConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end

    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; CombatTarget = nil; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; AutoFlingTarget = nil; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false;
    ToggleWallet(false)
    -- StopCustomAnims() -- [REMOVED: Animations persist during TP]

    -- NEW PARSING LOGIC TO SUPPORT: tp! <victim> <dest_player>
    local passenger = nil
    local destination = nil
    local destIsPlace = false
    local destVector = nil
    local destPlayer = nil
    
    local a1 = arg1 and arg1:lower() or ""
    local a2 = arg2 and arg2:lower() or ""

    local locCheck = TpLocations[a1]
    local p1 = Stand:FindTargetPlayer(arg1)
    local p2 = Stand:FindTargetPlayer(arg2)

    if locCheck then
        -- Case 1: tp! bank [user] (Old behavior)
        destIsPlace = true
        destVector = locCheck
        if a2 ~= "" then
            passenger = p2
        else
            passenger = Stand.FollowTarget or Stand.OwnerPlayer or Stand:FindOwner()
        end
        print("[TP] Mode: Place. Dest: " .. a1)
    elseif p1 and p2 then
        -- Case 2: tp! userA userB
        passenger = p1
        destPlayer = p2
        destIsPlace = false
        print("[TP] Mode: Player->Player. Bringing " .. p1.Name .. " to " .. p2.Name)
    elseif p1 and (not arg2 or a2 == "") then
        -- Case 3: tp! userA
        passenger = Stand.FollowTarget or Stand.OwnerPlayer or Stand:FindOwner()
        destPlayer = p1
        destIsPlace = false
        print("[TP] Mode: Owner->Player. Bringing Owner to " .. p1.Name)
    else
        warn("[TP] Invalid arguments. Usage: tp! <place> [victim] OR tp! <victim> <dest_player>")
        Stand:Fade()
        return
    end

    if not passenger then
        print("[TP] Passenger not found")
        Stand:Fade()
        return
    end

    if not passenger.Character or not passenger.Character:FindFirstChild("HumanoidRootPart") then
        print("[TP] Passenger character missing")
        Stand:Fade()
        return
    end

    IsTeleporting = true 

    task.spawn(function()
        local success, err = pcall(function()
            local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local HRP = Character:WaitForChild("HumanoidRootPart")
            local Humanoid = Character:WaitForChild("Humanoid")

            -- Unequip tools first to ensure clean state
            UnequipTools()
            task.wait(0.1)

            -- 1. SEARCH FOR EXISTING BIKE IN WORKSPACE FIRST (Updated robustness)
            local bike = nil
            local vehicleFolders = {Workspace:FindFirstChild("OldVehicles"), Workspace:FindFirstChild("Vehicles"), Workspace}
            
            print("[TP] Scanning Workspace for existing bikes...")
            for _, folder in ipairs(vehicleFolders) do
                if folder and not bike then
                    for _, v in ipairs(folder:GetChildren()) do
                        -- Prioritize checking for ownership (VehicleSeat usually handled by game logic)
                        if v.Name == "FoodsCart" or v.Name == "Cart" or v.Name:find(LocalPlayer.Name) then 
                             if v:FindFirstChild("VehicleSeat") then
                                bike = v
                                print("[TP] Found existing bike in " .. folder.Name .. ": " .. v.Name)
                                break
                             end
                        end
                    end
                end
            end

            -- 2. IF NO BIKE IN WORKSPACE, CHECK INVENTORY OR BUY
            if not bike then
                local Backpack = LocalPlayer:FindFirstChild("Backpack")
                local existingTool = Backpack:FindFirstChild("FoodsCart") or Backpack:FindFirstChild("[FoodsCart]")
                
                if existingTool then
                    -- We have the tool, just equip it
                    print("[TP] Found Cart in Inventory. Equipping...")
                    existingTool.Parent = Character
                    task.wait(1) -- Wait for bike to spawn
                else
                    -- We don't have the tool, BUY IT
                    print("[TP] No existing bike or tool found, purchasing...")
                    local shopItem = FindShopItem("FoodsCart") 
                    if not shopItem then 
                         warn("Bike Shop item (FoodsCart) not found - Cannot TP") 
                         IsTeleporting = false
                         Stand:Fade()
                         return 
                    end

                    local shopHead = shopItem:FindFirstChild("Head")
                    local shopClick = shopItem:FindFirstChild("ClickDetector")
                    if not shopHead or not shopClick then 
                        warn("Bike Shop parts missing")
                        IsTeleporting = false
                        Stand:Fade()
                        return 
                    end
                    
                    HRP.CFrame = shopHead.CFrame * CFrame.new(0, 3, 0)
                    HRP.Velocity = Vector3.zero
                    task.wait(0.2)
                    pcall(function() fireclickdetector(shopClick) end)
                    task.wait(0.5) -- Wait for spawn
                end
                
                -- Search Workspace again after Equipping/Buying
                local searchStart = os.time()
                while (os.time() - searchStart) < 5 and not bike do
                    for _, folder in ipairs(vehicleFolders) do
                        if folder and not bike then
                            for _, v in ipairs(folder:GetChildren()) do
                                if (v.Name == "FoodsCart" or v.Name == "Cart" or v.Name:find(LocalPlayer.Name)) and v:FindFirstChild("VehicleSeat") then
                                    bike = v
                                    break
                                end
                            end
                        end
                    end
                    task.wait(0.2)
                end
            end

            if not bike then
                warn("Bike did not spawn/exist")
                return
            end

            local vehicleSeat = bike:WaitForChild("VehicleSeat", 5)
            local passengerSeat = bike:WaitForChild("Seat", 5)
            if not vehicleSeat then return end

            -- 3. Sit Driver
            Humanoid.Sit = false
            task.wait(0.1)
            Humanoid.Jump = true
            task.wait(0.1)

            local sitAttempts = 0
            while not vehicleSeat:FindFirstChild("SeatWeld") and sitAttempts < 30 and IsTeleporting do
                HRP.CFrame = vehicleSeat.CFrame
                HRP.Velocity = Vector3.zero
                
                vehicleSeat:Sit(Humanoid)
                pcall(function()
                    firetouchinterest(HRP, vehicleSeat, 0)
                    firetouchinterest(HRP, vehicleSeat, 1)
                end)
                
                task.wait(0.1)
                sitAttempts = sitAttempts + 1
            end

            if not vehicleSeat:FindFirstChild("SeatWeld") then
                 print("[TP] Failed to sit in driver seat")
                 return
            end
            print("[TP] Driver seated. Capturing passenger...")

            -- 4. Capture Passenger Loop
            local captureStart = os.clock()
            local maxCaptureTime = 10
            
            while IsTeleporting and bike.Parent and not passengerSeat:FindFirstChild("SeatWeld") and (os.clock() - captureStart < maxCaptureTime) do
                if passenger and passenger.Character and passenger.Character:FindFirstChild("HumanoidRootPart") then
                    HRP.CFrame = passenger.Character.HumanoidRootPart.CFrame
                    HRP.Velocity = Vector3.zero
                    HRP.RotVelocity = Vector3.zero
                end
                RunService.Heartbeat:Wait()
            end

            if not passengerSeat:FindFirstChild("SeatWeld") then
                print("[TP] Failed to capture passenger (Timeout)")
                -- NOTE: We do NOT destroy here anymore to prevent item loss
                IsTeleporting = false
                Stand:Fade()
                return
            end
            
            print("[TP] Passenger captured! Transporting...")

            -- 5. Transport Loop
            local transportConnection
            transportConnection = RunService.Heartbeat:Connect(function()
                if bike.Parent and IsTeleporting then
                    HRP.AssemblyLinearVelocity = Vector3.zero 
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    
                    if destIsPlace and destVector then
                        local pos = destVector.hold or destVector.drop
                        HRP.CFrame = CFrame.new(pos)
                    elseif destPlayer and destPlayer.Character and destPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        HRP.CFrame = destPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
                    end
                end
            end)

            task.wait(1.5)
            
            if destIsPlace and destVector.drop then
                HRP.CFrame = CFrame.new(destVector.drop) + Vector3.new(0, 3, 0)
            end
            
            print("[TP] Arrived. Waiting for passenger exit...")
            
            if transportConnection then transportConnection:Disconnect() end
            
            pcall(function()
                for _, part in ipairs(bike:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Velocity = Vector3.zero
                    end
                end
            end)

            local exitWaitTime = 0
            local maxWait = 60 
            
            while passengerSeat:FindFirstChild("SeatWeld") and exitWaitTime < maxWait and IsTeleporting and bike.Parent do
                 task.wait(0.1)
                 exitWaitTime = exitWaitTime + 0.1
            end

            task.wait(0.2)
            Humanoid.Sit = false
            task.wait(0.1)
            Humanoid.Jump = true
            
            -- FIX: REMOVED THE BIKE DESTROY LINE
            -- if bike then bike:Destroy() end <--- This line caused your issue
            
            print("[TP] Transport Complete")
        end)
        
        if not success then
             warn("[TP] Critical Error: " .. tostring(err))
        end

        IsTeleporting = false
        Stand:Fade() 
    end)
end

-- ==================== NEW COMMANDS: SPECTATE (v!) & UNDERGROUND ATTACK (a!) ====================

local function handleSpectate(target)
    if not target then return end
    print("[Spectate] Viewing " .. target.Name)
    local camera = Workspace.CurrentCamera
    if target.Character and target.Character:FindFirstChild("Humanoid") then
        camera.CameraSubject = target.Character.Humanoid
    end
end

local function handleUnSpectate()
    print("[Spectate] Returned view to local player")
    local camera = Workspace.CurrentCamera
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        camera.CameraSubject = LocalPlayer.Character.Humanoid
    end
end

-- Proper definition of ActivateUndergroundAttack (was forward declared earlier)
ActivateUndergroundAttack = function(target)
    if not target then return end
    print("[Underground] Attacking " .. target.Name .. " from below!")
    ToggleWallet(false)
    
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    isKnockMode = false; isGrabMode = false; isStompMode = false; isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isFlinging = false; isAutoFling = false; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false;
    
    CombatTarget = target
    isUndergroundAttack = true
    
    pcall(function()
        local Backpack = LocalPlayer:FindFirstChild("Backpack")
        local Combat = Backpack and Backpack:FindFirstChild("Combat")
        if Combat then Combat.Parent = LocalPlayer.Character end
    end)
    
    task.spawn(function()
        while isUndergroundAttack and ScriptRunning do
            if not CombatTarget or not CombatTarget.Parent then break end
            
            pcall(function()
                local tChar = CombatTarget.Character
                local mChar = LocalPlayer.Character
                
                if tChar and mChar and tChar:FindFirstChild("HumanoidRootPart") and mChar:FindFirstChild("HumanoidRootPart") then
                    
                    if HasForceField(tChar) then
                        return
                    end

                    local tHRP = tChar.HumanoidRootPart
                    local mHRP = mChar.HumanoidRootPart
                    
                    -- UPDATED: Check for K.O. Status
                    if IsTargetKO(tChar) then
                        -- Wait in void until they get up
                        mHRP.CFrame = CFrame.new(0, -100, 0)
                        task.wait(0.1)
                        return
                    end

                    -- UPDATED: Small Prediction Logic (0.12s)
                    local predPos = tHRP.Position + (tHRP.Velocity * 0.12)
                    
                    mHRP.CFrame = CFrame.new(predPos) * CFrame.new(0, -3.5, 0) * CFrame.Angles(math.rad(90), 0, 0)
                    mHRP.Velocity = Vector3.zero
                    
                    local tool = mChar:FindFirstChild("Combat")
                    if tool then
                        tool:Activate()
                    else
                         local Backpack = LocalPlayer:FindFirstChild("Backpack")
                         local Combat = Backpack and Backpack:FindFirstChild("Combat")
                         if Combat then Combat.Parent = mChar end
                    end
                end
            end)
            RunService.Heartbeat:Wait()
        end
    end)
end

-- ==================== NEW COMMAND: FLING (fling!) & AUTOFLING (autofling!) ====================

local function ActivateFlingMode(target)
    if not target then return end
    print("[Fling] Initiating fling on " .. target.Name)
    ToggleWallet(false)
    
    -- Reset other modes
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    
    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isAutoFling = false; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false
    
    isFlinging = true
    CombatTarget = target

    FlingConnection = RunService.Heartbeat:Connect(function()
        if not isFlinging or not ScriptRunning then
            if FlingConnection then FlingConnection:Disconnect() end
            return
        end

        local tChar = target.Character
        local mChar = LocalPlayer.Character

        if not tChar or not mChar then return end
        
        local tHRP = tChar:FindFirstChild("HumanoidRootPart")
        local mHRP = mChar:FindFirstChild("HumanoidRootPart")
        
        if not tHRP or not mHRP then return end

        -- Stop Condition: Abnormally high velocity on target
        if tHRP.Velocity.Magnitude > 100 then
            print("[Fling] Target flung! Velocity: " .. tostring(tHRP.Velocity.Magnitude))
            isFlinging = false
            FlingConnection:Disconnect()
            Stand:Fade()
            return
        end

        pcall(function()
            -- Prediction Logic
            local predPos = tHRP.Position + (tHRP.Velocity * 0.1)
            -- Jitter around predicted position
            local randomOffset = Vector3.new(math.random(-2,2), 0, math.random(-2,2))
            
            mHRP.CFrame = CFrame.new(predPos + randomOffset)
            -- High Velocity Fling
            mHRP.AssemblyLinearVelocity = Vector3.new(10000, 10000, 10000)
            mHRP.AssemblyAngularVelocity = Vector3.new(0, 10000, 0)
        end)
    end)
end

local function StartAutoFling(target)
    if not target then return end
    print("[AutoFling] Enabled persistent fling on " .. target.Name)
    ToggleWallet(false)

    -- Reset other modes
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    
    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

    isAutoFling = true
    AutoFlingTarget = target
    
    task.spawn(function()
        while isAutoFling and ScriptRunning do
            if not AutoFlingTarget or not AutoFlingTarget.Parent then break end
            local tChar = AutoFlingTarget.Character
            local mChar = LocalPlayer.Character
            
            -- Valid checks
            if tChar and mChar and tChar:FindFirstChild("HumanoidRootPart") and mChar:FindFirstChild("HumanoidRootPart") then
                local tHRP = tChar.HumanoidRootPart
                local mHRP = mChar.HumanoidRootPart
                
                -- Check stability (low velocity = needs flinging)
                if tHRP.AssemblyLinearVelocity.Magnitude < 50 then
                    -- Execute Fling Pulse
                    pcall(function()
                         mHRP.CFrame = tHRP.CFrame
                         mHRP.AssemblyLinearVelocity = Vector3.new(9e9, 9e9, 9e9)
                         mHRP.AssemblyAngularVelocity = Vector3.new(9e9, 9e9, 9e9)
                    end)
                    task.wait(0.15)
                    
                    -- Reset self slightly to stop infinite fly away
                    pcall(function()
                        mHRP.AssemblyLinearVelocity = Vector3.zero
                        mHRP.AssemblyAngularVelocity = Vector3.zero
                        mHRP.CFrame = CFrame.new(0, 100000, 0) -- Teleport away briefly
                    end)
                    task.wait(0.1)
                end
            else
                -- Target dead or respawning, wait
            end
            task.wait(0.05)
        end
    end)
end

-- ==================== NEW COMMANDS: FS! & FL! (Flamethrower Stick) ====================

local function BuyFlamethrower()
    local item = FindShopItem("[Flamethrower]")
    if not item then print("[AutoBuy] Flamethrower shop node not found.") return end
    
    local cd = item:FindFirstChild("ClickDetector")
    local head = item:FindFirstChild("Head")
    if not cd or not head then return end
    
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    hrp.CFrame = head.CFrame * CFrame.new(0, 3, 0)
    hrp.Velocity = Vector3.zero
    task.wait(0.2)
    pcall(function() fireclickdetector(cd) end)
    hrp.CFrame = CFrame.new(0, 10000000, 0)
    task.wait(0.2)
end

local function BuyFlamethrowerAmmo()
    local item = FindShopItem("[Flamethrower Ammo]")
    if not item then return end
    
    local cd = item:FindFirstChild("ClickDetector")
    local head = item:FindFirstChild("Head")
    if not cd or not head then return end
    
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    -- Loop to ensure purchase registers (Fix for single click fail)
    for i = 1, 2 do
        hrp.CFrame = head.CFrame * CFrame.new(0, 3, 0)
        hrp.Velocity = Vector3.zero
        task.wait(0.2)
        pcall(function() fireclickdetector(cd) end)
        task.wait(0.1)
    end
    
    hrp.CFrame = CFrame.new(0, 10000000, 0)
    task.wait(0.2)
end

-- [NEW HELPER] Get Total Flamethrower Ammo from Inventory
local function GetTotalFlamethrowerAmmo()
    local dataFolder = LocalPlayer:FindFirstChild("DataFolder")
    if dataFolder then
        local inventory = dataFolder:FindFirstChild("Inventory")
        if inventory then
            local ammoData = inventory:FindFirstChild("[Flamethrower]")
            if ammoData then
                return tonumber(ammoData.Value) or 0
            end
        end
    end
    return 0
end

local function handleFlamethrowerStick(target, isLoop)
    if not target then return end

    -- Disable AutoBlock
    if getgenv().AutoBlock then
        getgenv().AutoBlock = false
        print("[FS] AutoBlock Disabled for Flamethrower Logic")
    end
    
    ToggleWallet(false)
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    
    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; isSyncStomp = false; isSyncLoop = false;
    
    isFlamethrowerStick = true
    CombatTarget = target

    -- SAFETY WAIT: Allow AutoBlock to detect the flag change before we start logic
    task.wait() 

    task.spawn(function()
        -- 1. Check and Buy Flamethrower
        local hasTool = false
        if LocalPlayer.Backpack:FindFirstChild("[Flamethrower]") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("[Flamethrower]")) then
             hasTool = true
        end
        
        if not hasTool then
             print("[FS] Buying Flamethrower...")
             UnequipTools()
             BuyFlamethrower()
        end
        
        -- 2. Equip
        local tool = LocalPlayer.Backpack:FindFirstChild("[Flamethrower]") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("[Flamethrower]"))
        if tool then
            LocalPlayer.Character.Humanoid:EquipTool(tool)
        else
            print("[FS] Flamethrower buy failed.")
            if not isLoop then Stand:Fade() end
            return
        end
        
        task.wait(0.1)
        tool = LocalPlayer.Character:FindFirstChild("[Flamethrower]") -- Re-reference after equip

        -- 3. Check Ammo (IMPROVED CHECK)
        local totalFlamethrowerAmmo = GetTotalFlamethrowerAmmo()
        
        if tool and tool:FindFirstChild("Ammo") then
             -- Check if both clip AND reserve are empty
             if tool.Ammo.Value <= 0 and tonumber(totalFlamethrowerAmmo) <= 0 then
                 print("[FS] Total Ammo empty. Buying x2...")
                 UnequipTools()
                 BuyFlamethrowerAmmo()
                 task.wait(0.1)
                 BuyFlamethrowerAmmo()
                 task.wait(0.1)
                 LocalPlayer.Character.Humanoid:EquipTool(LocalPlayer.Backpack:FindFirstChild("[Flamethrower]"))
                 tool = LocalPlayer.Character:FindFirstChild("[Flamethrower]")
             end
        end

        if not tool then
             if not isLoop then Stand:Fade() end
             return
        end

        -- 4. Glue Logic Loop (Using requested method)
        local inputManager = VirtualInputManager
        
        while isFlamethrowerStick and ScriptRunning do
            -- Ensure Stand is NOT active to prevent random strafing/following
            Stand.IsActive = false
            
            -- Validation
            if not target or not target.Character then
                print("[FS] Target Lost.")
                break
            end

            -- Dead Check
            if IsTargetDead(target.Character) then
                 print("[FS] Target Eliminated.")
                 break
            end
            
            -- FORCE FLAMETHROWER EQUIP LOGIC
            if LocalPlayer.Character then
                for _, xTool in ipairs(LocalPlayer.Character:GetChildren()) do
                    if xTool:IsA("Tool") and xTool.Name ~= "[Flamethrower]" then
                        xTool.Parent = LocalPlayer.Backpack
                    end
                end
                
                local equippedFT = LocalPlayer.Character:FindFirstChild("[Flamethrower]")
                if not equippedFT then
                     local backpackFT = LocalPlayer.Backpack:FindFirstChild("[Flamethrower]")
                     if backpackFT then
                         LocalPlayer.Character.Humanoid:EquipTool(backpackFT)
                         tool = LocalPlayer.Character:FindFirstChild("[Flamethrower]")
                     end
                else
                     tool = equippedFT
                end
            end
            -- END FORCE LOGIC

            local isKO = IsTargetKO(target.Character)
            local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
            local targetTorso = target.Character:FindFirstChild("UpperTorso") or target.Character:FindFirstChild("Torso")
            
            if myRoot and targetRoot then
                if isKO and targetTorso then
                     -- REQUIREMENT: K.O. Checker - Teleport to UpperTorso (0,3,0) WORLD COORDINATES
                     pcall(function() sethiddenproperty(myRoot, "PhysicsRepRootPart", nil) end) -- Un-glue
                     
                     -- New: World Coordinate Position + Preserve Rotation
                     local targetPos = targetTorso.Position + Vector3.new(0, 3, 0)
                     myRoot.CFrame = CFrame.new(targetPos) * myRoot.CFrame.Rotation
                     
                     myRoot.Velocity = Vector3.zero
                     myRoot.RotVelocity = Vector3.zero
                     
                     -- Release trigger so we don't shoot while stomping (optional but cleaner)
                     inputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                     
                     MainEvent:FireServer("Stomp")
                else
                    -- REQUIREMENT: Alive Logic - Offset (0, 4, 28) with High Speed Orbit
                    pcall(function()
                        sethiddenproperty(myRoot, "PhysicsRepRootPart", targetRoot)
                    end)
                    
                    -- Orbit Math
                    local orbitSpeed = 15 -- High speed orbit
                    local orbitRotation = CFrame.Angles(0, os.clock() * orbitSpeed, 0)
                    local orbitOffset = CFrame.new(0, 4, 28)
                    
                    myRoot.CFrame = targetRoot.CFrame * orbitRotation * orbitOffset
                    myRoot.Velocity = Vector3.zero
                    
                    -- Reload/Shoot Logic
                    if tool and tool:FindFirstChild("Ammo") and tool.Ammo.Value <= 0 then
                        -- Check reserve before reloading
                        local reserve = GetTotalFlamethrowerAmmo()
                        
                        if reserve > 0 then
                            print("[FS] Reloading in Void...")
                            inputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1) -- Release
                            
                            -- UNGLUE and VOID
                            pcall(function() sethiddenproperty(myRoot, "PhysicsRepRootPart", nil) end)
                            myRoot.CFrame = CFrame.new(0, 10000000, 0)
                            myRoot.Velocity = Vector3.zero
                            
                            MainEvent:FireServer("Reload", tool)
                            task.wait(2.5) -- Wait for reload anim in void
                        else
                            print("[FS] Out of ammo mid-fight! Buying...")
                            inputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1) -- Release
                            UnequipTools()
                            BuyFlamethrowerAmmo()
                            task.wait(0.1)
                            BuyFlamethrowerAmmo()
                            task.wait(0.1)
                            local newTool = LocalPlayer.Backpack:FindFirstChild("[Flamethrower]")
                            if newTool then LocalPlayer.Character.Humanoid:EquipTool(newTool) end
                            tool = LocalPlayer.Character:FindFirstChild("[Flamethrower]")
                            task.wait(0.5)
                        end
                    else
                        -- Hold Shoot
                        inputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
                    end
                end
            end
            
            RunService.Heartbeat:Wait()
        end
        
        -- Cleanup
        inputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1) -- Release
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if myRoot then
             pcall(function()
                sethiddenproperty(myRoot, "PhysicsRepRootPart", nil)
            end)
        end
        
        isFlamethrowerStick = false
        print("[FS] Sequence complete. Re-enabling AutoBlock.") -- [ADDED: Log]
        getgenv().AutoBlock = true -- [ADDED: Re-enable AutoBlock]
        
        -- REMOVED: Automatic Stomp Logic (per request)
        -- if not isLoop then
        --      if ActivateStompMode then ActivateStompMode(target) end
        -- end
    end)
end

local function handleFlamethrowerLoop(target)
    if not target then return end

    -- Disable AutoBlock
    if getgenv().AutoBlock then
        getgenv().AutoBlock = false
        print("[FL] AutoBlock Disabled for Flamethrower Loop")
    end
    
    print("[FL] Starting Flamethrower Loop on " .. target.Name)
    ToggleWallet(false)
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end

    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; isSyncStomp = false; isSyncLoop = false; isFlamethrowerStick = false;
    
    isFlamethrowerLoop = true
    
    task.spawn(function()
        while isFlamethrowerLoop and ScriptRunning do
            if not target or not target.Character then
                 -- Wait for respawn
                 task.wait(1)
            else
                 if HasForceField(target.Character) then
                      -- Wait in void
                      local char = LocalPlayer.Character
                      if char and char:FindFirstChild("HumanoidRootPart") then
                          char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
                      end
                      task.wait(0.2)
                 else
                      -- Execute FS Logic
                      if not isFlamethrowerStick then
                           handleFlamethrowerStick(target, true) -- true for isLoop
                      end
                      -- Wait until fs finishes (KO/Dead)
                      while isFlamethrowerStick do task.wait(0.1) end
                      
                      -- Stomp logic is part of FS finish, but in loop we ensure they die
                      if IsTargetKO(target.Character) then
                           if ActivateStompMode then ActivateStompMode(target) end
                           -- Wait for Stomp to finish
                           while isStompMode do task.wait(0.1) end
                      end
                 end
            end
            task.wait(0.5)
        end
    end)
end

-- ==================== MULTI-TARGET QUEUE SYSTEM ====================

-- Function to parse comma-separated string into players
local function ResolveMultiTargets(query)
    local targets = {}
    for s in query:gmatch("[^,]+") do
        -- Trim whitespace
        s = s:match("^%s*(.-)%s*$")
        if s ~= "" then
            local p = Stand:FindTargetPlayer(s)
            if p then
                table.insert(targets, p)
            else
                print("[MultiTarget] Could not find player for: " .. s)
            end
        end
    end
    return targets
end

-- Queue Processor Loop
task.spawn(function()
    while ScriptRunning do
        task.wait(0.5)
        
        -- Check if current task is done (CombatTarget nil) and Queue has items
        if #MultiTargetQueue > 0 and CombatTarget == nil and not isBuying and not isBuyingGun and not isSavingOwner and not IsTeleporting and not isFlinging and not isAutoFling and not isUndergroundAttack and not isKnockMode and not isStompMode and not isGrabMode and not isSyncStomp and not isSyncLoop and not isFlamethrowerStick and not isFlamethrowerLoop then
            
            -- Wait a brief moment to ensure Fade logic has cleared old state
            task.wait(0.5)
            
            local nextData = table.remove(MultiTargetQueue, 1)
            local mode = nextData.mode
            local plr = nextData.player
            
            if plr and plr.Parent then
                print("[MultiTarget] Processing Next: " .. plr.Name .. " [" .. mode .. "]")
                
                if mode == "knock" then
                    ActivateKnockMode(plr)
                elseif mode == "stomp" then
                    ActivateStompMode(plr)
                elseif mode == "bring" then
                    ActivateBringMode(plr)
                elseif mode == "loop" then
                    ActivateLoopMode(plr)
                elseif mode == "underground" then
                    ActivateUndergroundAttack(plr)
                elseif mode == "fling" then
                    ActivateFlingMode(plr)
                end
            end
        end
    end
end)

-- ==================== COMBAT COMMAND HANDLERS (UPDATED) ====================

-- // ==================== SYNC COMBAT SYSTEM (ss! / sl!) ==================== \\

local function GetSmoothedPing()
    local Stats = game:GetService("Stats")
    local total = 0
    local count = 5
    for i = 1, count do
        local p = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
        if p <= 0 then p = LocalPlayer:GetNetworkPing() end
        total = total + p
        RunService.Heartbeat:Wait()
    end
    return total / count
end

local function GetFlatCFrame(targetCFrame, backOffset, heightOffset)
    local pos = targetCFrame.Position
    local _, yRot, _ = targetCFrame:ToOrientation()
    return CFrame.new(pos) * CFrame.Angles(0, yRot, 0) * CFrame.new(0, heightOffset, backOffset)
end

local function ConnectPartToPart(BasePart, ConnecterPart)
    local isGrounded = false
    pcall(function() isGrounded = BasePart:IsGrounded() end)

    if not isGrounded then
        local oldMat = ConnecterPart.Material
        local oldAnchored = ConnecterPart.Anchored
        local oldCanCollide = ConnecterPart.CanCollide
        local oldProps = ConnecterPart.CustomPhysicalProperties
        local oldParent = ConnecterPart.Parent
        
        local baseParent = BasePart.Parent
        local baseName = BasePart.Name
        local baseProps = BasePart.CustomPhysicalProperties
        
        local HolderModel = Instance.new("Model", workspace)
        local HolderHumanoid = Instance.new("Humanoid", HolderModel)
        HolderHumanoid.RequiresNeck = false
        HolderHumanoid.HipHeight = 2 

        ConnecterPart.Material = Enum.Material.ClayRoofTiles 
        ConnecterPart.Parent = workspace
        ConnecterPart.CustomPhysicalProperties = PhysicalProperties.new(100, 0, 0) 
        ConnecterPart.Anchored = false 
        ConnecterPart.CanCollide = true 

        BasePart.CanCollide = false
        BasePart.Name = "HumanoidRootPart"
        BasePart.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0, 0) 
        BasePart.Parent = HolderModel

        local start = tick()
        -- Пытаемся синхронизировать физику
        local Heartbeat = game:GetService("RunService").Heartbeat
        repeat
            HolderHumanoid:ChangeState(Enum.HumanoidStateType.Running)
            ConnecterPart.AssemblyLinearVelocity = Vector3.zero
            ConnecterPart.AssemblyAngularVelocity = Vector3.zero
            
            BasePart.CFrame = GetFlatCFrame(ConnecterPart.CFrame, 0, 2) 
            BasePart.AssemblyLinearVelocity = Vector3.zero
            Heartbeat:Wait()
            if tick() - start > 1 then break end 
        until HolderHumanoid.FloorMaterial == ConnecterPart.Material

        HolderHumanoid:Destroy()
        BasePart.Parent = baseParent
        BasePart.Name = baseName
        BasePart.CustomPhysicalProperties = baseProps
        HolderModel:Destroy()
        ConnecterPart.Parent = oldParent
        ConnecterPart.Anchored = oldAnchored
        ConnecterPart.Material = oldMat
        ConnecterPart.CustomPhysicalProperties = oldProps
        ConnecterPart.CanCollide = oldCanCollide
        return true
    end
    return false
end

local function EquipAndPunch()
    local Char = LocalPlayer.Character
    if not Char then return end
    
    local Humanoid = Char:FindFirstChild("Humanoid")
    local Tool = Char:FindFirstChild("Combat") or LocalPlayer.Backpack:FindFirstChild("Combat")
    
    if Tool and Humanoid then
        Humanoid:EquipTool(Tool)
        Tool:Activate()
        print("⚔️ Punch Activated (Fade state)")
    end
end

local function ExecuteSyncAttack(target)
    if not target or not target.Character then return false end
    local tChar = target.Character
    local tHRP = tChar:FindFirstChild("HumanoidRootPart")
    
    if not tHRP then return false end
    
    -- ForceField Check 1
    if HasForceField(tChar) then
         print("[Sync] Target has FF, aborting.")
         return false
    end

    local MyChar = LocalPlayer.Character
    local MyHRP = MyChar and MyChar:FindFirstChild("HumanoidRootPart")
    local MyHumanoid = MyChar and MyChar:FindFirstChild("Humanoid")
    
    if not MyHRP or not MyHumanoid then return false end

    -- 1. FADE (Random Void) & PREPARE
    MyHRP.CFrame = CFrame.new(math.random(-100000, 100000), math.random(100000, 200000), math.random(-100000, 100000))
    MyHRP.Velocity = Vector3.zero
    
    -- 2. ACTIVATE TOOL (Punch)
    EquipAndPunch()
    
    -- 3. CALCULATE DELAY (Smart Ping)
    local realPing = GetSmoothedPing()
    local ACTION_TIME_CONST = 1.8
    local waitDelay = ACTION_TIME_CONST - realPing
    if waitDelay < 0.2 then waitDelay = 0.2 end -- Safety clamp
    
    print(string.format("[Sync] Delaying %.3fs (Ping: %.3f)", waitDelay, realPing))
    
    -- 4. WAIT IN VOID (While punch animation plays)
    local startTime = tick()
    while tick() - startTime < waitDelay do
        if not target.Parent or HasForceField(tChar) then return false end
        -- Keep in void
        MyHRP.CFrame = CFrame.new(0, 10000000, 0) 
        MyHRP.Velocity = Vector3.zero
        RunService.Heartbeat:Wait()
    end
    
    -- ForceField Check 2 (After Wait)
    if HasForceField(tChar) then return false end
    
    -- 5. TELEPORT & GLUE LOGIC
    local ReturnCFrame = MyHRP.CFrame
    local OffsetBack = 2.8
    local HeightOffset = 0

    local noc = RunService.Stepped:Connect(function()
        for _, v in pairs(MyChar:GetDescendants()) do
            if v:IsA("BasePart") then v.CanCollide = false end
        end
    end)

    -- Connect Physics
    ConnectPartToPart(MyHRP, tHRP)

    MyHumanoid.PlatformStand = true
    
    local holdDuration = 0.2 + (realPing * 0.5) 
    local connection
    
    -- Stick Loop
    connection = RunService.Heartbeat:Connect(function()
        if not tHRP or not MyHRP then return end
        local desiredCF = GetFlatCFrame(tHRP.CFrame, OffsetBack, HeightOffset)
        MyHRP.CFrame = desiredCF
        MyHRP.AssemblyLinearVelocity = Vector3.zero
        MyHRP.AssemblyAngularVelocity = Vector3.zero
    end)
    
    task.wait(holdDuration)
    
    -- 6. CLEANUP & STOMP LOOP (UPDATED PER REQUEST)
    if connection then connection:Disconnect() end
    if noc then noc:Disconnect() end
    MyHumanoid.PlatformStand = false
    
    local stompStart = os.clock()
    local stompTimeout = 6 -- Give it time to stomp
    
    while (os.clock() - stompStart < stompTimeout) do
        -- Target Validation
        if not target.Parent or not tChar.Parent then break end
        
        -- 1. Check Dead
        if IsTargetDead(tChar) then 
            print("[Sync] Target Eliminated.")
            break 
        end
        
        -- 2. Check KO
        if IsTargetKO(tChar) then
             -- REQ: TP to UpperTorso every frame
             local tTorso = tChar:FindFirstChild("UpperTorso") or tChar:FindFirstChild("Torso")
             if tTorso then
                 MyHRP.CFrame = tTorso.CFrame * CFrame.new(0, 2.6, 0) -- On top
                 MyHRP.Velocity = Vector3.zero
                 MyHRP.RotVelocity = Vector3.zero
                 
                 -- REQ: Fire Stomp Event every frame
                 MainEvent:FireServer("Stomp")
             end
        else
            -- If not KO yet (maybe lag), stay close
             local desiredCF = GetFlatCFrame(tHRP.CFrame, OffsetBack, HeightOffset)
             MyHRP.CFrame = desiredCF
             MyHRP.Velocity = Vector3.zero
        end
        
        RunService.Heartbeat:Wait()
    end
    
    -- Return to void
    MyHRP.CFrame = CFrame.new(0, 10000000, 0)
    
    return true
end

local function handleSyncStomp(targetQuery)
    local target = Stand:FindTargetPlayer(targetQuery)
    if not target then print("[SS] Target not found") return end
    
    print("[SS] Sync Stomp Initiated on " .. target.Name)
    ToggleWallet(false)
    
    -- Reset other modes
    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; isFlamethrowerStick = false; isFlamethrowerLoop = false
    
    -- Set SS Flag to prevent other loops
    isSyncStomp = true
    isSyncLoop = false
    CombatTarget = target

    task.spawn(function()
        ExecuteSyncAttack(target)
        task.wait(0.5)
        Stand:Fade()
        isSyncStomp = false
    end)
end

local function handleSyncLoop(targetQuery)
    local target = Stand:FindTargetPlayer(targetQuery)
    if not target then print("[SL] Target not found") return end

    print("[SL] Sync Loop Initiated on " .. target.Name)
    ToggleWallet(false)

    Stand.IsActive = false
    if Stand.FollowConnection then pcall(function() Stand.FollowConnection:Disconnect() end) Stand.FollowConnection = nil end
    if FadeConnection then pcall(function() FadeConnection:Disconnect() end) FadeConnection = nil end
    if FlingConnection then pcall(function() FlingConnection:Disconnect() end) FlingConnection = nil end
    if FlamethrowerConnection then pcall(function() FlamethrowerConnection:Disconnect() end) FlamethrowerConnection = nil end
    isKnockMode = false; isGrabMode = false; isStompMode = false; isLoopMode = false
    isVoidSpam = false; IsTeleporting = false; isSavingOwner = false; isUndergroundAttack = false; isFlinging = false; isAutoFling = false; isFlamethrowerStick = false; isFlamethrowerLoop = false

    isSyncLoop = true
    isSyncStomp = false
    CombatTarget = target

    task.spawn(function()
        while isSyncLoop and ScriptRunning do
            if not target or not target.Parent then break end
            
            -- REQ: ForceField Check for sl!
            if target.Character and HasForceField(target.Character) then
                 print("[SL] Target has ForceField - Waiting...")
                 -- Wait in void
                 local char = LocalPlayer.Character
                 if char and char:FindFirstChild("HumanoidRootPart") then
                     char.HumanoidRootPart.CFrame = CFrame.new(0, 10000000, 0)
                     char.HumanoidRootPart.Velocity = Vector3.zero
                 end
                 task.wait(0.2)
            else
                 -- Execute Sequence
                 ExecuteSyncAttack(target)
                 reloadTool()
                 task.wait(0.2)
            end
        end
        Stand:Fade()
    end)
end

local function handleGKnockCommand(targetQuery)
    targetQuery = targetQuery:lower()
    
    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="knock", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Knock Queue")
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            ActivateKnockMode(player)
            return
        end
    end
    print("[Knock] Target not found")
end

local function handleGBringCommand(targetQuery)
    targetQuery = targetQuery:lower()

    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="bring", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Bring Queue")
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            ActivateBringMode(player)
            return
        end
    end
    print("[Bring] Target not found")
end

local function handleStompCommand(targetQuery)
    targetQuery = targetQuery:lower()

    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="stomp", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Stomp Queue")
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            ActivateStompMode(player)
            return
        end
    end
    print("[Stomp] Target not found")
end

local function handleLoopCommand(targetQuery)
    targetQuery = targetQuery:lower()

    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="loop", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Loop Queue")
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            ActivateLoopMode(player)
            return
        end
    end
    print("[Loop] Target not found")
end

local function handleFlingCommand(targetQuery)
    targetQuery = targetQuery:lower()

    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="fling", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Fling Queue")
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()
        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            ActivateFlingMode(player)
            return
        end
    end
    print("[Fling] Target not found")
end

local function handleUndergroundCommand(targetQuery)
    targetQuery = targetQuery:lower()

    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            table.insert(MultiTargetQueue, {mode="underground", player=p})
        end
        print("[MultiTarget] Added " .. #targets .. " players to Underground Queue")
        return
    end
    
    local target = Stand:FindTargetPlayer(targetQuery)
    if target then
        ActivateUndergroundAttack(target)
    else
        print("[Underground] Target not found")
    end
end

local function handleFixCommand()
    print("Fix: Clearing states and Forcing Unsit...")
    
    -- Clear Multi-Target Queue
    MultiTargetQueue = {}
    
    -- Ungrab Owner if caught
    MainEvent:FireServer("Grabbing", false)
    
    -- Remove BP/BG from Owner
    pcall(function()
        local Owner = Stand.OwnerPlayer or Stand:FindOwner()
        if Owner and Owner.Character then
            local Torso = Owner.Character:FindFirstChild("UpperTorso") or Owner.Character:FindFirstChild("Torso")
            if Torso then
                if Torso:FindFirstChild("BodyPosition") then Torso.BodyPosition:Destroy() end
                if Torso:FindFirstChild("BodyGyro") then Torso.BodyGyro:Destroy() end
            end
        end
    end)

    -- UPDATED: Force jump/unsit
    pcall(function()
        local Character = LocalPlayer.Character
        if Character and Character:FindFirstChild("Humanoid") then
             Character.Humanoid.Sit = false
             Character.Humanoid.Jump = true
        end
    end)

    pcall(function()
        getgenv().enabled = false
        getgenv().enabled1 = false
        getgenv().downonly = false
    end)
    
    CombatResume = {Active=false}

    CombatTarget = nil
    isShooting = false
    isIdle = true
    isBuying = false
    isBuyingGun = false
    isKnockMode = false
    isGrabMode = false
    isStompMode = false
    isLoopMode = false
    isVoidSpam = false
    IsTeleporting = false
    isSavingOwner = false
    isUndergroundAttack = false
    isFlinging = false
    isAutoFling = false -- Reset Autofling
    AutoFlingTarget = nil
    BaitRunning = false
    isSyncStomp = false
    isSyncLoop = false
    isFlamethrowerStick = false
    isFlamethrowerLoop = false

    AutoBuy.isBuying = false
    AutoBuy.isEquipping = false

    if grabbingConnection then
        pcall(function() grabbingConnection:Disconnect() end)
        grabbingConnection = nil
    end

    if FadeConnection then
        pcall(function() FadeConnection:Disconnect() end)
        FadeConnection = nil
    end
    
    if FlingConnection then
        pcall(function() FlingConnection:Disconnect() end)
        FlingConnection = nil
    end

    if FlamethrowerConnection then
        pcall(function() FlamethrowerConnection:Disconnect() end)
        FlamethrowerConnection = nil
    end

    if Stand.FollowConnection then
        pcall(function() Stand.FollowConnection:Disconnect() end)
        Stand.FollowConnection = nil
    end

    if Stand.TargetConnection then
        pcall(function() Stand.TargetConnection:Disconnect() end)
        Stand.TargetConnection = nil
    end

    Stand.IsActive = false
    Stand.IsTargeting = false

    pcall(function()
        local Character = LocalPlayer.Character
        if Character then
            local hrp = Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Velocity = Vector3.zero
                hrp.RotVelocity = Vector3.zero
                hrp.AssemblyLinearVelocity = Vector3.zero
                hrp.AssemblyAngularVelocity = Vector3.zero
            end
        end
    end)

    reloadTool()
    UnequipTools()
    handleUnSpectate()
    ToggleWallet(false)
    
    task.wait(0.1)
    Stand:Fade()
    
    -- [ADDED: Re-enable AutoBlock after fix!]
    getgenv().AutoBlock = true
    print("[Fix] AutoBlock Re-enabled.")

    print("Fix: Complete - Sent to Void (Idle)")
end

-- ==================== PROTECTION COMMANDS ====================

local function handleProtectCommand(targetQuery)
    targetQuery = targetQuery:lower()
    local found = false
    ToggleWallet(false)
    
    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            getgenv().sentryprotected[p.Name] = true
            print("[Protection] Added " .. p.Name)
        end
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            getgenv().sentryprotected[player.Name] = true
            print("[Protection] " .. player.Name .. " added to protection list")
            found = true
            break
        end
    end

    if not found then
        print("[Protection] Player not found: " .. targetQuery)
    end
end

local function handleUnprotectCommand(targetQuery)
    targetQuery = targetQuery:lower()
    local found = false
    
    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            getgenv().sentryprotected[p.Name] = nil
            print("[Protection] Removed " .. p.Name)
        end
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            getgenv().sentryprotected[player.Name] = nil
            print("[Protection] " .. player.Name .. " removed from protection list")
            found = true
            break
        end
    end

    if not found then
        print("[Protection] Player not found: " .. targetQuery)
    end
end

-- NEW: Whitelist Commands
local function handleWhitelistCommand(targetQuery)
    targetQuery = targetQuery:lower()
    local found = false
    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            getgenv().whitelisted[p.Name] = true
            print("[Whitelist] Added " .. p.Name)
        end
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower(); local displayName = player.DisplayName:lower()
        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            getgenv().whitelisted[player.Name] = true
            print("[Whitelist] " .. player.Name .. " added.")
            found = true; break
        end
    end
    if not found then print("[Whitelist] Player not found") end
end

local function handleUnwhitelistCommand(targetQuery)
    targetQuery = targetQuery:lower()
    local found = false
    if targetQuery:find(",") then
        local targets = ResolveMultiTargets(targetQuery)
        for _, p in ipairs(targets) do
            getgenv().whitelisted[p.Name] = nil
            print("[Whitelist] Removed " .. p.Name)
        end
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        local name = player.Name:lower(); local displayName = player.DisplayName:lower()
        if name:find(targetQuery, 1, true) or displayName:find(targetQuery, 1, true) then
            getgenv().whitelisted[player.Name] = nil
            print("[Whitelist] " .. player.Name .. " removed.")
            found = true; break
        end
    end
    if not found then print("[Whitelist] Player not found") end
end

-- ==================== CHAT LISTENER SYSTEM ====================

function Stand:SetupOwnerChatListener(player)
    if not player then
        return
    end

    if OwnerChatConnections[player.UserId] then
        OwnerChatConnections[player.UserId]:Disconnect()
    end

    print("Stand: Listening to commands from " .. player.Name)

    local connection = player.Chatted:Connect(function(message)
        task.wait() 
        pcall(function()
            local msg = message:lower()

            if AutoBuy.isBuying or isBuying or isBuyingGun then
                return
            end

            if msg == "vanta!" or msg == "va!" then
                ToggleWallet(false)
                -- STABILITY: Reset before calling
                if Stand.IsActive or isKnockMode or isGrabMode then Stand:Fade() task.wait(0.1) end
                
                pcall(function()
                     local text = "I answer your summons only, Master."
                     SendChatMessage(text)
                end)
                Stand:Call()
                print("Summoned via va!")
            elseif msg == "f!" or msg == "vanish!" then
                ToggleWallet(false)
                Stand:Fade()
                getgenv().AutoBlock = true -- [ADDED: Re-enable AutoBlock after Fade]
                print("[Fade] AutoBlock Re-enabled.")
            elseif msg == "untarget!" then
                ToggleWallet(false)
                Stand:Untarget()
            elseif msg:match("^target!%s+(.+)$") then
                local targetQuery = msg:match("^target!%s+(.+)$")
                local target = Stand:FindTargetPlayer(targetQuery)
                if target then
                    Stand:Target(target)
                else
                    print("Stand: Target not found")
                end

            elseif msg:match("^fr!%s+(.+)$") then
                 ToggleWallet(false)
                 local targetQuery = msg:match("^fr!%s+(.+)$")
                 local target = Stand:FindTargetPlayer(targetQuery)
                 if target then
                     print("Stand: Redirecting follow to " .. target.Name)
                     Stand.FollowTarget = target

                     if Stand.FollowConnection then
                         pcall(function() Stand.FollowConnection:Disconnect() end)
                         Stand.FollowConnection = nil
                     end
                     Stand.IsActive = false

                     Stand:Call()
                 else
                     print("Stand: User for fr! not found")
                 end

            elseif msg == "unfr!" then
                 ToggleWallet(false)
                 print("Stand: Resetting follow to owner")
                 if not Stand.OwnerPlayer then Stand:FindOwner() end
                 Stand.FollowTarget = nil
                 if Stand.FollowConnection then
                     pcall(function() Stand.FollowConnection:Disconnect() end)
                     Stand.FollowConnection = nil
                 end
                 Stand.IsActive = false
                 Stand:Call()

            elseif msg:match("^g!%s+(.+)$") then
                 ToggleWallet(false)
                 local targetQuery = msg:match("^g!%s+(.+)$")
                 local target = Stand:FindTargetPlayer(targetQuery)
                 if target then
                     print("Stand: Transferring ownership to " .. target.Name)
                     if OwnerChatConnections[player.UserId] and player.Name ~= ORIGINAL_OWNER_NAME then
                         OwnerChatConnections[player.UserId]:Disconnect()
                         OwnerChatConnections[player.UserId] = nil
                     end

                     Stand.OwnerPlayer = target
                     Stand.FollowTarget = target

                     if Stand.FollowConnection then
                         pcall(function() Stand.FollowConnection:Disconnect() end)
                         Stand.FollowConnection = nil
                     end
                     Stand.IsActive = false

                     Stand:SetupOwnerChatListener(target)
                     Stand:Call()
                 else
                     print("Stand: User for g! not found")
                 end

            elseif msg:match("^t!%s+(.+)$") then
                 ToggleWallet(false)
                 local chatMsg = message:sub(4) 
                 if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
                     local channel = TextChatService.TextChannels.RBXGeneral
                     if channel then
                         channel:SendAsync(chatMsg)
                     end
                 else
                     ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(chatMsg, "All")
                 end

            elseif msg:match("^tp!%s+([^%s]+)%s*(.*)$") then
                local arg1, arg2 = msg:match("^tp!%s+([^%s]+)%s*(.*)$")
                handleTpCommand(arg1, arg2)

            elseif msg:match("^v!%s+(.+)$") then
                local targetQuery = msg:match("^v!%s+(.+)$")
                local target = Stand:FindTargetPlayer(targetQuery)
                if target then
                    handleSpectate(target)
                end
            elseif msg == "unv!" then
                handleUnSpectate()

            elseif msg:match("^a!%s+(.+)$") then
                local targetQuery = msg:match("^a!%s+(.+)$")
                handleUndergroundCommand(targetQuery)
            elseif msg:match("^una!%s+(.+)$") or msg == "una!" then
                print("[Underground] Stopping attack")
                isUndergroundAttack = false
                Stand:Fade()
            
            -- NEW SYNC COMMANDS (ss! / sl!) - Replaces .sk
            elseif msg:match("^ss!%s+(.+)$") then
                local targetQuery = msg:match("^ss!%s+(.+)$")
                handleSyncStomp(targetQuery)
            elseif msg:match("^sl!%s+(.+)$") then
                local targetQuery = msg:match("^sl!%s+(.+)$")
                handleSyncLoop(targetQuery)

            elseif msg:match("^k!%s+(.+)$") then
                local targetQuery = msg:match("^k!%s+(.+)$")
                handleGKnockCommand(targetQuery)
            elseif msg:match("^b!%s+(.+)$") then
                local targetQuery = msg:match("^b!%s+(.+)$")
                handleGBringCommand(targetQuery)
            elseif msg:match("^s!%s+(.+)$") or msg:match("^stomp!%s+(.+)$") then
                local targetQuery = msg:match("^s!%s+(.+)$") or msg:match("^stomp!%s+(.+)$")
                handleStompCommand(targetQuery)
            elseif msg:match("^l!%s+(.+)$") or msg:match("^loop!%s+(.+)$") then
                local targetQuery = msg:match("^l!%s+(.+)$") or msg:match("^loop!%s+(.+)$")
                handleLoopCommand(targetQuery)
            
            elseif msg:match("^fling!%s+(.+)$") then
                local targetQuery = msg:match("^fling!%s+(.+)$")
                handleFlingCommand(targetQuery)
                
            -- NEW AUTOFLING COMMAND
            elseif msg:match("^autofling!%s+(.+)$") then
                local targetQuery = msg:match("^autofling!%s+(.+)$")
                local target = Stand:FindTargetPlayer(targetQuery)
                if target then
                    StartAutoFling(target)
                else
                    print("AutoFling: User not found")
                end
            
            -- NEW FLAMETHROWER COMMANDS (FS! / FL!)
            elseif msg:match("^fs!%s+(.+)$") then
                local targetQuery = msg:match("^fs!%s+(.+)$")
                local target = Stand:FindTargetPlayer(targetQuery)
                if target then
                    handleFlamethrowerStick(target, false)
                else
                    print("[FS] Target not found")
                end
            elseif msg:match("^fl!%s+(.+)$") then
                local targetQuery = msg:match("^fl!%s+(.+)$")
                local target = Stand:FindTargetPlayer(targetQuery)
                if target then
                    handleFlamethrowerLoop(target)
                else
                    print("[FL] Target not found")
                end

            elseif msg:match("^p!%s+(.+)$") then
                local targetQuery = msg:match("^p!%s+(.+)$")
                handleProtectCommand(targetQuery)
            elseif msg:match("^unp!%s+(.+)$") then
                local targetQuery = msg:match("^unp!%s+(.+)$")
                handleUnprotectCommand(targetQuery)

            elseif msg:match("^pwl!%s+(.+)$") then
                local targetQuery = msg:match("^pwl!%s+(.+)$")
                handleWhitelistCommand(targetQuery)
            elseif msg:match("^unpwl!%s+(.+)$") then
                local targetQuery = msg:match("^unpwl!%s+(.+)$")
                handleUnwhitelistCommand(targetQuery)

            elseif msg == "as! on" then
                handleAutoSave(true)
            elseif msg == "as! off" then
                handleAutoSave(false)
            
            elseif msg == "advtext! on" then
                getgenv().AdvText = true
                print("AdvText Enabled")
            elseif msg == "advtext! off" then
                getgenv().AdvText = false
                print("AdvText Disabled")

            elseif msg == "fp!" then
                handleFpCommand()
            elseif msg == "unfp!" then
                handleUnfpCommand()
                
            -- NEW: Velocity Breaker Command
            elseif msg == "vb! on" then
                getgenv().VelocityBreaker = true
                print("[Velocity Breaker] Enabled")
            elseif msg == "vb! off" then
                getgenv().VelocityBreaker = false
                print("[Velocity Breaker] Disabled")

            elseif msg == "bait! on" then
                BaitConfig.Enabled = true
                print("Bait Mode ON")
            elseif msg == "bait! off" then
                BaitConfig.Enabled = false
                print("Bait Mode OFF")
            elseif msg == "multi! on" then
                Multistand = true
                print("Multistand Mode ON")
            elseif msg == "multi! off" then
                Multistand = false
                print("Multistand Mode OFF")

            elseif msg == "vs! on" then
                handleVoidSpam(true)
            elseif msg == "vs! off" then
                handleVoidSpam(false)
            elseif msg == "vd!" then
                handleVoidDrop()
            elseif msg == "fix!" then
                handleFixCommand()
            elseif msg == "rj!" or msg == "rejoin!" then
                print("Rejoin: Rejoining server...")
                local TeleportService = game:GetService("TeleportService")
                local plr = Players.LocalPlayer
                
                -- Attempt to rejoin the specific server instance
                if game.JobId ~= "" then
                    local success, err = pcall(function()
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, plr)
                    end)
                    
                    -- If rejoining fails (server full/closed), fallback to random server
                    if not success then
                        warn("Rejoin: Instance join failed, finding new server...")
                        TeleportService:Teleport(game.PlaceId, plr)
                    end
                else
                    -- No JobId (likely solo test or VIP), just reload place
                    TeleportService:Teleport(game.PlaceId, plr)
                end
            
            -- NEW: Wallet Commands
            elseif msg == "wallet! show" then
                ToggleWallet(true)
                print("Wallet Equipped")
            elseif msg == "wallet! hide" then
                ToggleWallet(false)
                print("Wallet Unequipped")

            -- NEW: Drop Cash Command
            elseif msg:match("^dcash!%s+(%d+)$") or msg:match("^dropcash!%s+(%d+)$") then
                ToggleWallet(false)
                local amountStr = msg:match("%d+")
                local amount = tonumber(amountStr)
                if amount and amount >= 100 and amount <= 15000 then
                     MainEvent:FireServer("DropMoney", tostring(amount))
                     print("Dropped Cash: " .. amount)
                end

                -- [ SENSEI ANIMATION REMOVED ] --
            elseif msg == "sensei! on" then
               print("Sensei Animation: REMOVED (Optimized)")
            elseif msg == "sensei! off" then
               print("Sensei Animation: REMOVED (Optimized)")
            
            -- [ FIX: INVITE COMMAND ] --
            elseif msg == "inv!" then
                local invites = {"g g/JHHGneSJ9g", "JHHGneSJ9g", "G G/JHHGneSJ9g"}
                SendChatMessage(invites[math.random(1, #invites)])

            -- [ FIX: ADVANCED COMBAT TOGGLE ] --
            -- Use "off" to make k!/s! instant/faster (removes spiral/desync)
            elseif msg == "advcombat! on" or msg == "desync! on" then
                getgenv().UseAdvancedCombat = true
                print("Advanced Combat (Spiral/Desync): ON")
            elseif msg == "advcombat! off" or msg == "desync! off" then
                getgenv().UseAdvancedCombat = false
                print("Advanced Combat (Spiral/Desync): OFF - Instant Kill Mode Active")
            
            -- NEW: Fire Armor Toggles
            elseif msg == "firearmor! on" then
                getgenv().FireArmorautobuy = true
                print("Fire Armor AutoBuy: ON")
            elseif msg == "firearmor! off" then
                getgenv().FireArmorautobuy = false
                print("Fire Armor AutoBuy: OFF")
            
            -- NEW: Auto Block Toggles
            elseif msg == "ab! on" or msg == "autoblock! on" then
                getgenv().AutoBlock = true
                print("AutoBlock ON")
            elseif msg == "ab! off" or msg == "autoblock! off" then
                getgenv().AutoBlock = false
                print("AutoBlock OFF")

            -- NEW: Positioning Commands (MIRROR LOGIC)
            elseif msg == "left!" then
                Stand.Offset = Vector3.new(-3, 4, 4) -- Default (Left side)
                Stand:Call()
                print("Stand Position: Left")
            elseif msg == "right!" then
                Stand.Offset = Vector3.new(3, 4, 4) -- Mirrored X (Right side)
                Stand:Call()
                print("Stand Position: Right")
                
            -- NEW: Optimization Commands
            elseif msg == "optimize! on" then
                RunService:Set3dRenderingEnabled(false)
                print("3D Rendering Disabled")
            elseif msg == "optimize! off" then
                RunService:Set3dRenderingEnabled(true)
                print("3D Rendering Enabled")

            elseif msg == "close!" then
                print("Close: Shutting down script and killing player...")
                ToggleWallet(false)
                -- StopCustomAnims() -- [REMOVED]

                ScriptRunning = false
                CombatResume = {Active=false}

                CombatTarget = nil
                MultiTargetQueue = {}
                isShooting = false
                isIdle = false
                isBuying = false
                isBuyingGun = false
                isKnockMode = false
                isGrabMode = false
                isStompMode = false
                isLoopMode = false
                isVoidSpam = false
                IsTeleporting = false
                isSavingOwner = false
                isUndergroundAttack = false
                isFlinging = false
                isAutoFling = false
                AutoFlingTarget = nil
                isSyncStomp = false
                isSyncLoop = false
                isFlamethrowerStick = false
                isFlamethrowerLoop = false
                AutoBuy.isBuying = false
                AutoBuy.isEquipping = false
                BaitRunning = false
                getgenv().VelocityBreaker = false
                getgenv().AutoBlock = false
                
                -- Close marker
                if getgenv().Resolver and getgenv().Resolver.Marker then
                    getgenv().Resolver.Marker:Destroy()
                end

                if grabbingConnection then
                    pcall(function() grabbingConnection:Disconnect() end)
                    grabbingConnection = nil
                end
                if FadeConnection then
                    pcall(function() FadeConnection:Disconnect() end)
                    FadeConnection = nil
                end
                if FlingConnection then
                    pcall(function() FlingConnection:Disconnect() end)
                    FlingConnection = nil
                end
                if FlamethrowerConnection then
                    pcall(function() FlamethrowerConnection:Disconnect() end)
                    FlamethrowerConnection = nil
                end
                if Stand.FollowConnection then
                    pcall(function() Stand.FollowConnection:Disconnect() end)
                    Stand.FollowConnection = nil
                end
                if Stand.TargetConnection then
                    pcall(function() Stand.TargetConnection:Disconnect() end)
                    Stand.TargetConnection = nil
                end

                for userId, conn in pairs(OwnerChatConnections) do
                    pcall(function() conn:Disconnect() end)
                end
                OwnerChatConnections = {}

                Stand.IsActive = false
                Stand.IsTargeting = false
                
                handleUnSpectate()

                pcall(function()
                    workspace.FallenPartsDestroyHeight = -500
                end)

                pcall(function()
                    local Character = LocalPlayer.Character
                    if Character then
                        local Humanoid = Character:FindFirstChild("Humanoid")
                        if Humanoid then
                            Humanoid.Health = 0
                        end
                    end
                end)
                
                -- Ensure 3D rendering is back on if closed
                pcall(function() RunService:Set3dRenderingEnabled(true) end)

                print("Close: All loops terminated, connections disconnected, player killed")
                print("Close: Script fully shutdown")
            end 
        end) 
    end) 

    OwnerChatConnections[player.UserId] = connection
end

function Stand:MonitorOriginalOwner()
    local function hookOriginalOwner(player)
        if player.Name == ORIGINAL_OWNER_NAME then
            print("Stand: Original Owner Monitor Hooked on " .. player.Name)
            player.Chatted:Connect(function(msg)
                if msg:lower() == "r!" then
                    print("Stand: Force Return initiated by Original Owner")

                    if Stand.OwnerPlayer and Stand.OwnerPlayer.Name ~= ORIGINAL_OWNER_NAME then
                        if OwnerChatConnections[Stand.OwnerPlayer.UserId] then
                            OwnerChatConnections[Stand.OwnerPlayer.UserId]:Disconnect()
                            OwnerChatConnections[Stand.OwnerPlayer.UserId] = nil
                        end
                    end

                    Stand.OwnerPlayer = player
                    Stand.FollowTarget = nil 

                    if Stand.FollowConnection then
                         pcall(function() Stand.FollowConnection:Disconnect() end)
                         Stand.FollowConnection = nil
                    end
                    Stand.IsActive = false

                    Stand:SetupOwnerChatListener(player)
                    Stand:Call()
                end
            end)
        end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        hookOriginalOwner(p)
    end

    Players.PlayerAdded:Connect(hookOriginalOwner)
end

-- ==================== INITIALIZATION ====================

-- // ==================== NEW: AUTO FADE ON RELOAD LOGIC ==================== //
local IsReloadFading = false
task.spawn(function()
    while ScriptRunning do
        task.wait()
        local char = LocalPlayer.Character
        if char then
            local be = char:FindFirstChild("BodyEffects")
            local reload = be and be:FindFirstChild("Reload")
            
            if reload then
                if reload.Value == true then
                    -- If we are reloading and not currently handled by this logic
                    if not IsReloadFading and not AutoBuy.isBuying and not isBuying and not isBuyingGun then
                        IsReloadFading = true
                        print("[System] Reload detected: Activating Fade...")
                        Stand:Fade()
                    end
                elseif reload.Value == false then
                    -- If we were handled by this logic and reload stopped
                    if IsReloadFading then
                        IsReloadFading = false
                        print("[System] Reload complete: Resuming Stand...")
                        -- Stand:Call() -- [DISABLED AUTOMATIC RETURN]
                        Stand:Fade() -- Stay in void
                    end
                end
            end
        end
    end
end)

function Stand:Init()
    Stand.OwnerPlayer = Stand:FindOwner()

    Stand.FollowTarget = nil

    if not LocalPlayer.Character then
        LocalPlayer.CharacterAdded:Wait()
    end

    print("Stand: Initialized")

    if Stand.OwnerPlayer then
        Stand:SetupOwnerChatListener(Stand.OwnerPlayer)
        print("Stand: Owner listener set for " .. Stand.OwnerPlayer.Name)
    else
        print("Stand: WARNING - Owner not found: " .. OwnerUsername)
    end

    Stand:MonitorOriginalOwner()
    
    Stand:Fade()
end

Stand:Init()

warn([[

██╗   ██╗ █████╗ ███╗   ██╗████████╗ █████╗ 
██║   ██║██╔══██╗████╗  ██║╚══██╔══╝██╔══██╗
██║   ██║███████║██╔██╗ ██║   ██║   ███████║
╚██╗ ██╔╝██╔══██║██║╚██╗██║   ██║   ██╔══██║
 ╚████╔╝ ██║  ██║██║ ╚████║   ██║   ██║  ██║
  ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝

]])
